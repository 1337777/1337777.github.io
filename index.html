<!--
  This sample contains two very simple introductory exercises of
  interactive proofs in Coq, one with natural numbers and one with lists.
  It can be used as a gentle landing page, which requires no knowledge
  of math-comp.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <meta name="description" content="An Online IDE for the Coq Theorem Prover" />

    <title>Use Coq in Your Browser: The Js Coq Theorem Prover Online IDE!</title>
  </head>

<body>
  <div id="ide-wrapper" class="toggled">
  <div id="code-wrapper">
  <div id="document">
    <p>
      Short ：the objective of the "鸡算计.在线" is to enable everyone to read and write mathematics . In the next 5 years to 10 years , this could be used in the national education .
    </p>
    <p>
      短 : “鸡算计.在线”的目的是让每个人都能读写数学。在未来5年到10年，这可以用于国民教育。
    </p>
    <p>
    </p>
    <ul>
  <li><a href="qoc_jisuanji_logic_variables_proof.html">qoc_jisuanji_logic_variables_proof</a></li>
  <li><a href="qoc_jisuanji_inductive.html">qoc_jisuanji_inductive</a></li>
  <li><a href="qoc_jisuanji_polymorphism_notation.html">qoc_jisuanji_polymorphism_notation</a></li>
  <li><a href="qoc_jisuanji_parameter_option.html">qoc_jisuanji_parameter_option</a></li>
  <li><a href="qoc_jisuanji_tactics.html">qoc_jisuanji_tactics</a></li>
  <li><a href="qoc_jisuanji_environmental_parametrized_module.html">qoc_jisuanji_environmental_parametrized_module</a></li>
  <li><a href="qoc_jisuanji_tactical.html">qoc_jisuanji_tactical</a></li>
  <li><a href="qoc_jisuanji_search_error.html">qoc_jisuanji_search_error</a></li>
  <li><a href="qoc_jisuanji_ends.html">qoc_jisuanji_ends</a></li>
</ul>
    <p>
    </p>
    <ul>
  <li><a href="수탉수학/">수탉수학</a></li>
</ul>
    <p>
    Alt+↑/↓ – move through proof; Alt+→ or Alt+⏎ – go to cursor. <br/>
    Alt+hover executed sentences to watch intermediate steps. <br/>
    Hover identifiers in goals to view their types. Alt+hover to view definitions.<br/>
    <i style="color: rgb(51, 51, 150)">Company-coq</i> addon is enabled: it will auto-complete names of tactics and lemmas 
    from the standard library, and also show types of lemmas in the right pane.
    </p>
    <p>
      “Alt +↑/↓” : 通过证明。 “Alt +→”或“Alt +⏎” : 转到光标。
      <br/> “Alt +”悬停执行句子以观察中间步骤。
      <br/> 将目标中的标识符悬停在其中以查看其类型。 “Alt +”悬停以查看定义。
      <br/> 启用“Company-coq”加载项：它将自动完成标准库中的策略和引理名称，并在右侧窗格中显示引导类型。
    </p>
    <textarea id="workspace">
From Qoc Require Import Jisuanji .

(** 


短 : “鸡算计.在线”的目的是让每个人都能读写数学。在未来5年到10年，这可以用于国民教育。

Short ：the objective of the "鸡算计.在线" is to enable everyone to read and write mathematics . In the next 5 years to 10 years , this could be used in the national education .

Outline ::
 * PART 1 : ENDS . 第1部分 : 目的们
 * PART 2 : MORE TACTICS . 第2部分：更多战术们

*)

(** * PART 1 : ENDS . 第1部分 : 目的们 *)

(** 

http://鸡算计.在线
http://xn--lzzm24a52n.xn--3ds443g/

短 : “鸡算计.在线”的目的是让每个人都能读写数学。在未来5年到10年，这可以用于国民教育。

Short ：the objective of the "鸡算计.在线" is to enable everyone to read and write mathematics . In the next 5 years to 10 years , this could be used in the national education .


*)


(** * PART 2 : MORE TACTICS . 第2部分：更多战术们 *)

(**cs3110 *)

(** 假设 *)
论点 p_implies_p : forall P : Prop,
  P -> P.
证明.
  移动外 P P_holds.
  假设.
据证实.


(** 同一 , 对称 , transitivity *)
论点 forty_two : 41 + 1 = 42.
证明.
  同一.
退出.
论点 forty_two : 41 + 1 = 42.
  对称. 同一.
退出.
论点 forty_two : 41 + 1 = 42.
  外传递. 确切 (eq_refl (3 + (38 + 1))).
  同一.
退出.

(** 琐细 *)
论点 p_implies_p' : forall P : Prop,
  P  -> P .
证明.
  琐细.
据证实.

(** 自动 *)
论点 modus_tollens: forall (P Q : Prop),
  (P -> Q) -> ~Q -> ~P.
证明.
  自动.
据证实.

(** 辨析 *)
论点 false_implies_anything : forall P : Prop,
  0 = 1 -> P.
证明.
  移动外 P zero_equals_one.
  辨析.
据证实.

(** 确切 *)
论点 everything : 42 = 42.
证明.
  确切 (eq_refl 42).
据证实.

(** 矛盾 *)

论点 law_of_矛盾 : forall (P Q : Prop),
  P -> ~P -> Q.
证明.
  移动外 P Q P_and_not_P.
  矛盾.
据证实.

(** Transforming goals *)

(** 移动外 *)
论点 my移动外 : forall A B C D : Prop, D .
证明.
  移动外 A B C .
退出.

(** 简化 *)
论点 switch_to_honors : 10 + 2 = 12.
证明.
  计时了 简化.
  计时了 同一.
退出.

(** 展开 *)
定义 plus_two (x : nat) : nat :=
  x + 2.

论点 switch_to_honors_again : 
  plus_two 10 = 12.
证明.
  展开 plus_two.
  同一.
据证实.

(** 应用 *)
论点 modus_ponens : forall (P Q : Prop),
  (P -> Q) -> P -> Q.
证明.
  移动外 P Q P_implies_Q P_holds.
  应用 P_implies_Q.
退出. 

论点 modus_ponens'' : forall (P Q : Prop),
  P -> (P -> Q) -> Q.
证明.
  自动.
据证实.

论点 double_negation : forall (P : Prop),
  P -> ~~P.
证明.
  展开 not. 移动外个 P.
  应用 modus_ponens''.
据证实.

(** rewrite *)
论点 add_comm : forall (x y : nat),
  x + y = y + x.
证明.
  移动外. 归纳 x 如 [ | x' IHx' ].
  - 琐细.
  - 简化. 改写 -> IHx'.
    琐细.
据证实.

(** 逆温 *)
论点 succ_eq_implies_eq : forall (x y : nat),
  S x = S y -> x = y.
证明.
  移动外 x y succ_eq.
  逆温 succ_eq.
  琐细.
据证实.

(** 左 , 右 *)

论点 or_左 : forall (P Q : Prop),
  P -> P \/ Q.
证明.
  移动外 P Q P_holds.
  左.
退出.

论点 or_右 : forall (P Q : Prop),
  Q -> P \/ Q.
证明.
  移动外 P Q Q_holds.
  右.
退出.

(** 更换 *)
论点 one_x_one : forall (x : nat),
  1 + x + 1 = 2 + x.
证明.
  移动外个. 简化.
  更换 (x + 1) 与 (S x).
退出.

(** 分裂 *)
论点 implies_and : forall (P Q R : Prop),
  P -> (P -> Q) -> (P -> R) -> (Q /\ R).
证明.
  移动外 P Q R P_holds.
  移动外 P_implies_Q P_implies_R. 
  分裂. (* 复原. 构造函数. *)
  - 应用 P_implies_Q . 假设 .
  - 应用 P_implies_R . 假设 .
据证实.

论点 and_左 : forall (P Q : Prop),
  (P /\ Q) -> P.
证明.
  移动外 P Q P_and_Q.
  解构 P_and_Q 如 [P_holds Q_holds].
  假设.
据证实.

论点 or_comm : forall (P Q : Prop),
  P \/ Q -> Q \/ P.
证明.
  移动外 P Q P_or_Q.
  解构 P_or_Q 如 [P_holds | Q_holds].
  - 右. (* 复原. 构造函数 2. *)  假设.
  - 左. (* 复原. 构造函数 1. *) 假设.
据证实.

归纳的 element :=
| grass : element
| fire : element
| water : element.

定义 weakness (e : element) : element :=
  匹配 e 与
  | grass => fire
  | fire => water
  | water => grass
  结束.

论点 never_weak_to_self : forall (e : element),
  weakness e <> e.
证明.
  解构 e.
  - 简化. 辨析.
  - 简化. 辨析.
  - 简化. 辨析.
退出.


论点 n_plus_n : forall (n : nat),
  n + n = n * 2.
证明.
  归纳 n 如 [| x IH].
  - 同一.
  - 简化. 改写 <- IH. 自动.
据证实.


(** 自动 *)

(** logical t自动 *)
论点 demorgan : forall (P Q : Prop),
  ~(P \/ Q) -> ~P /\ ~Q.
证明.
  同义反复.
据证实.

从 Coq 要求 进口 Lia.
论点 dfoil : forall a ,
  (a + 2) * (1 + 2) = a*1 + 2*1 + a*2 + 2*2.
证明. 
  移动外. lia.
据证实.

从 Coq 要求 进口 Arith.
(** algebraic rihg *)
论点 foil : forall a b c d,
  (a + b) * (c + d) = a*c + b*c + a*d + b*d.
证明. 
  移动外. ring.
据证实.



(** ** alt
----------------------------------------------------------------------------- *)

Reset p_implies_p.


(** assumption *)
Lemma p_implies_p : forall P : Prop,
  P -> P.
Proof.
  intros P P_holds.
  assumption.
Qed.


(** reflexivity , symmetry , transitivity *)
Lemma forty_two : 41 + 1 = 42.
Proof.
  reflexivity. Undo.
  symmetry. reflexivity. Undo 2.
  etransitivity. exact (eq_refl (3 + (38 + 1))).
  reflexivity.
Abort.

(** trivial *)
Lemma p_implies_p' : forall P : Prop,
  P  -> P .
Proof.
  trivial.
Qed.

(** auto *)
Lemma modus_tollens: forall (P Q : Prop),
  (P -> Q) -> ~Q -> ~P.
Proof.
  auto.
Qed.

(** discriminate *)
Lemma false_implies_anything : forall P : Prop,
  0 = 1 -> P.
Proof.
  intros P zero_equals_one.
  discriminate.
Qed.

(** exact *)
Lemma everything : 42 = 42.
Proof.
  exact (eq_refl 42).
Qed.

(** contradiction *)

Lemma law_of_contradiction : forall (P Q : Prop),
  P -> ~P -> Q.
Proof.
  intros P Q P_and_not_P.
  contradiction.
Qed.

(** Transforming goals *)

(** intros *)
Lemma myintros : forall A B C D : Prop, D .
Proof.
  intros A B C .
Abort.

(** simpl *)
Lemma switch_to_honors : 10 + 2 = 12.
Proof.
  Time simpl.
  Time reflexivity.
Abort.

(** unfold *)
Definition plus_two (x : nat) : nat :=
  x + 2.

Lemma switch_to_honors_again : 
  plus_two 10 = 12.
Proof.
  unfold plus_two.
  reflexivity.
Qed.

(** apply *)
Lemma modus_ponens : forall (P Q : Prop),
  (P -> Q) -> P -> Q.
Proof.
  intros P Q P_implies_Q P_holds.
  apply P_implies_Q.
Abort. 

Lemma modus_ponens'' : forall (P Q : Prop),
  P -> (P -> Q) -> Q.
Proof.
  auto.
Qed.

Lemma double_negation : forall (P : Prop),
  P -> ~~P.
Proof.
  unfold not. intro P.
  apply modus_ponens''.
Qed.

(** rewrite *)
Lemma add_comm : forall (x y : nat),
  x + y = y + x.
Proof.
  intros. induction x as [ | x' IHx' ].
  - trivial.
  - simpl. rewrite -> IHx'.
    trivial.
Qed.

(** inversion *)
Lemma succ_eq_implies_eq : forall (x y : nat),
  S x = S y -> x = y.
Proof.
  intros x y succ_eq.
  inversion succ_eq.
  trivial.
Qed.

(** left , right *)

Lemma or_left : forall (P Q : Prop),
  P -> P \/ Q.
Proof.
  intros P Q P_holds.
  left.
Abort.

Lemma or_right : forall (P Q : Prop),
  Q -> P \/ Q.
Proof.
  intros P Q Q_holds.
  right.
Abort.

(** replace *)
Lemma one_x_one : forall (x : nat),
  1 + x + 1 = 2 + x.
Proof.
  intro. simpl.
  replace (x + 1) with (S x).
Abort.

(** split *)
Lemma implies_and : forall (P Q R : Prop),
  P -> (P -> Q) -> (P -> R) -> (Q /\ R).
Proof.
  intros P Q R P_holds.
  intros P_implies_Q P_implies_R. 
  split. Undo. constructor.
  - apply P_implies_Q . assumption .
  - apply P_implies_R . assumption .
Qed.

Lemma and_left : forall (P Q : Prop),
  (P /\ Q) -> P.
Proof.
  intros P Q P_and_Q.
  destruct P_and_Q as [P_holds Q_holds].
  assumption.
Qed.

Lemma or_comm : forall (P Q : Prop),
  P \/ Q -> Q \/ P.
Proof.
  intros P Q P_or_Q.
  destruct P_or_Q as [P_holds | Q_holds].
  - right. Undo. constructor 2.  assumption.
  - left. Undo. constructor 1. assumption.
Qed.

Inductive element :=
| grass : element
| fire : element
| water : element.

Definition weakness (e : element) : element :=
  match e with
  | grass => fire
  | fire => water
  | water => grass
  end.

Lemma never_weak_to_self : forall (e : element),
  weakness e <> e.
Proof.
  destruct e.
  - simpl. discriminate.
  - simpl. discriminate.
  - simpl. discriminate.
Abort.


Lemma n_plus_n : forall (n : nat),
  n + n = n * 2.
Proof.
  induction n as [| x IH].
  - reflexivity.
  - simpl. rewrite <- IH. auto.
Qed.


(** auto *)

(** logical tauto *)
Lemma demorgan : forall (P Q : Prop),
  ~(P \/ Q) -> ~P /\ ~Q.
Proof.
  tauto.
Qed.

From Coq Require Import Lia.
Lemma dfoil : forall a ,
  (a + 2) * (1 + 2) = a*1 + 2*1 + a*2 + 2*2.
Proof. 
  intros. lia.
Qed.

From Coq Require Import Arith.
(** algebraic rihg *)
Lemma foil : forall a b c d,
  (a + b) * (c + d) = a*c + b*c + a*d + b*d.
Proof. 
  intros. ring.
Qed.

</textarea>
  </div> <!-- /#document -->
  </div> <!-- /#code-wrapper -->
  </div> <!-- /#ide-wrapper -->

  <script src="../ui-js/jscoq-loader.js" type="text/javascript"></script>
  <script type="text/javascript">

    var jscoq_ids  = ['workspace'];
    var jscoq_opts = {
        prelude:   true,
        base_path: '../',
        init_pkgs: ['init', 'qoc'],
        all_pkgs:  ['init', 'qoc', 'coq-base', 'coq-collections', 'coq-arith', 'coq-reals', 'math-comp'],
        implicit_libs: true,
        editor: { mode: { 'company-coq': true }, keyMap: 'default' }
    };

    /* Global reference */
    var coq;

    loadJsCoq(jscoq_opts.base_path)
        .then( () => coq = new CoqManager(jscoq_ids, jscoq_opts) );
  </script>
</body>
</html>
