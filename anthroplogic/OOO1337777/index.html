<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-142610023-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-142610023-1');
</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>anthroplogic.com</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Ubuntu" />
<link rel="stylesheet" type="text/css" href="../../code/style.css"/>
<style>
#content {
    width: 100%;
    padding: 0px;
    font-size: 16px;
}
</style>
</head>
<body>

<div id="ide-wrapper" class="toggled">
<div id="code-wrapper">
<div id="document">
<div id="preamble" class="status">
<p></p>
</div>
<div id="content">

<h1 class="title">FOR EXAMPLE ...
<br> LIVE EVERY WEEK AT 22:22 KST </h1>
    
<br>
<iframe src="https://free.timeanddate.com/countdown/i6q2r7ew/n235/cf12/cm0/cu4/ct0/cs0/cacf00/co0/cr0/ss0/cacf90/cpc000/pct/tcfff/fn3/fs300/szw320/szh135/iso2019-07-05T22:22:00" allowTransparency="true" frameborder="0" width="330px" height="120" style="display: block; margin: 0 auto;" ></iframe>

<h3 style="text-align: center"><a href="https://youtube.com/results?search_query=OOO1337777">https://youtube.com/results?search_query=OOO1337777</a></h3>

<h3> In the next 37 days , I @OOO1337777 ( <a href="https://google.com/search?q=OOO1337777">https://google.com/search?q=OOO1337777</a> , <a href="https://baidu.com/s?wd=OOO1337777">https://baidu.com/s?wd=OOO1337777</a> ) will review the making-of the MODOS ( <a href="https://youtube.com/results?search_query=OOO1337777">https://youtube.com/results?search_query=OOO1337777</a> ) which is conjectured as the alpha-omega of modern computer mathematics . In short , the <a href="https://youtube.com/results?search_query=OOO1337777">MODOS</a> is : parametrized functional programming which is modified by functorial geometry .
</h3>

<p><b>Memo.</b> here are initial instant first-impressions : <a href="../../init.html">COQ computer english-mathematics</a> , <a href="../../">中文 鸡算计 computer chinese-mathematics</a> , <a href="../../수탉수학/">한국어 탉수학 computer korean-mathematics</a> . </p>

<h2 class="title" id="live1">LIVE 1 : can you steal some logic proof ? | BAD HUMAN VS COMPUTER |
<br> FRIDAY 21 JUNE 2019 AT 22:22 KST </h2>

  <p> Imagine that some person writes this logic proof of this logic formula ( in short this formula says that : <i>if I have a banana and an apple in my fridge , then I can eat a banana or an apple tonight ; moreover I am saying this phrase for any two food items ... </i> ) : </p>
  <p><em>Note : text edit this code by Alt+↑ , Alt+↓ , Alt+→ , Alt+⏎ , Alt+hover .</em></p>
  <textarea id="workspace1">
Lemma proof1 : forall A B : Prop , and A B -> or A B .
Proof.
  intros A B ab .
  left .
  destruct ab as [ a b ] .
  exact a .
Qed.
</textarea>
  <p> There are many possibilities/choices of logic proofs for this logic formula . Another proof may conclude by choosing <code>B</code> ( the right alternative ) : </p>
  <textarea id="workspace2">
Lemma proof2 : forall A B : Prop , and A B -> or A B .
Proof.
  intros A B ab .
  right .
  destruct ab as [ a b ] .
  exact b .
Qed.
</textarea>
<p> <b>Question</b> : Does this multitude of possibilities/choices signify that the search of some logic proof for this logic formula is some creative activity ? Can the logic proof written by the first person <b>be stolen</b> (copy-pasted) by some other person ? </p>
<p> Answer : most logic proofs can be searched automatically by the computer in less than 1 second . Therefore , there is no need to steal (copy-paste) another person's logic proof . Whatever theft would not occur in this manner . </p>
<p> Here is how to do the <b>automatic logic proof search</b> : </p>
  <textarea id="workspace3">
Lemma proof3 : forall A B : Prop , and A B -> or A B .
Proof.
  tauto .
Qed.
</textarea>

  <p><b>Dictionary.</b> What is the dictionary definition of "theft" ? <a href="https://www.thefreedictionary.com/theft">https://www.thefreedictionary.com/theft</a> says :</p>
  <ul> <li> <i> The <b>unlawful taking</b> of the property of another </i> </li>
    <li> <i> the <b>dishonest taking</b> of property belonging to another person with the intention of depriving the owner permanently of its possession </i> </li>
    <li> <i> the act of <b>taking</b> something from someone <b>unlawfully</b>; </i> </li>
  </ul>
  <p>The main words here are <i> "unlawful taking" </i> , <i> "dishonest taking" </i> . Therefore the words <i> "unlawful" </i> , <i> "dishonest" </i> says the same as <i> "to tell lies" </i> , <i> "to falsify" </i> ; and the words <i> "taking" </i> signify something as <i> "taking by force" </i> ( <i>"sudden/active force"</i> ) . But this <i> "force" </i> element need not be <i>"sudden/active force"</i> , such as to take someone's purse . This <i> "force" </i> element may be more  <i>"slow/passive force"</i> , such as to print money and therefore <i> "to convert the proportion" </i> of possession. The legislation definition will address this contrast .  </p>

  <p><b>Legislation.</b> What is the legislation definition of "theft" ? <a href="https://www.canlii.org/en/ca/laws/stat/rsc-1985-c-c-46/latest/rsc-1985-c-c-46.html#sec322subsec1">https://www.canlii.org/en/ca/laws/stat/rsc-1985-c-c-46/latest/rsc-1985-c-c-46.html#sec322subsec1</a> , at "Criminal Code, RSC 1985, c C-46 / PART IX — OFFENCES AGAINST RIGHTS OF PROPERTY [321 - 378] / THEFT [322 - 334]" , says :  </p>
  <p> <i>322 (1) Every one commits theft who <b>fraudulently</b> and <b>without colour of right</b> <b>takes, or</b> fraudulently and without colour of right <b>converts</b> to his use or to the use of another person, anything, whether animate or inanimate, with intent</i>
<ul> <li><i> (a) to deprive, temporarily or absolutely, the owner of it, or a person who has a special property or interest in it, of the thing or of his property or interest in it;</i></li>
<li><i> (b) to pledge it or deposit it as security;</i></li>
<li><i> (c) to part with it under a condition with respect to its return that the person who parts with it may be unable to perform; or</i></li>
<li><i> (d) to deal with it in such a manner that it cannot be restored in the condition in which it was at the time it was taken or converted.</i></li> </ul> </p>
  <p>And as expected , the main words here are <i> "fraudulently" </i> ( which says the same as <i> "unlawful" </i> , <i> "dishonest" </i> , <i> "to tell lies" </i> , <i> "to falsify" </i> ) , and  <i> "takes or converts" </i> .  </p>
  <p>Moreover the legislation , mentions <i> "without colour of right" </i> . This signify that although the suspect may believe to have <i> "colour of right" </i> ( =  <i> "expected morality" </i> , = <i> "expected justification" </i> ) , the reality is that the suspect is <i> "without colour of right" </i> ( = <b> "fool" </b> ) . For example , the suspect may believe the ambiguous/confused statement <i> "the nights repeat twice each day" </i> for indirect calculations , instead of choosing to see the direct reality . </p>
  <p> In short , "absence of truth/reality/actuality/be" or "bad logic" can be rephrased as : <b> forced-fool-and-theft/lie/falsification </b> </p>

<h2 class="title" id="live2">LIVE 2 : majority is meaningless without (fibred/multiplied/pullback) intersection with some explicit totality/domain ! | BAD HUMAN VS COMPUTER |
<br> FRIDAY 28 JUNE 2019 AT 22:22 KST </h2>

  <p><b>Logic.</b> The ends is to compose/sequence two functions when the output of the first function is not included within the input of the subsequent functiion . The solution is : to intersec the input of the first function (so that its output is) within the input of the subsequent function .    
  </p>

  <p>First of all , when the ouput of the first function [f] is the same as the input of the subsequent function [g] , it is easy to compose the two functions simply by composing/sequencing their effect .
 </p>
  <p><em>Note : text edit this code by Alt+↑ , Alt+↓ , Alt+→ , Alt+⏎ , Alt+hover .</em></p>
  <textarea id="workspace4">
Section section_composition.

(*
     f           g
A ------>   B  ----->   C

a |----->  f a |----> g (f a)   

*)  
 
  Variables (A : Type) (B : Type) (f : A -> B ).
  Variables (C : Type) (g : B -> C) .

  Definition composition : A -> C
    := fun a => g ( f a )  .

End section_composition.
</textarea>
<p>How to express that the output of the first function is NOT the same as the input of the subsequent function ?</p>

<p>Solution : by generalizing from the idea of function to the idea of function with reindexed/restricted/multiplied input : [ B_ <--b-- B --g--> C ] . Now the restriction function [b] should be <b>read backward</b> , and the effectful function [g] should be <b>read forward</b> . </p>
  
  <textarea id="workspace5">
Section section_reindexed_function.
(*
     g
 B ------> C
 |
 . b
 |
 v
 B_

 *)
  
  Variables (B_ : Type) (B : Type) (b : B -> B_) (C : Type) (g : B -> C) .

(*
Example :

.  
.   .
.   .
  _
  |
  | b
  v
 
. . .

*)
  </textarea>
<p> Therefore any function can be read forward (the effectful orientation) or read backward (the reindexer/multiplier orientation). Here is the composition/sequencing of two functions when read backward : </p>

<p style="text-align:center;"><img src="function_read_backward.svg"></p>

<p>  The question now is : how to compose/sequence two reindexed functions ( functions with reindexed/restricted/multiplied inputs ) such as (a <o> f) then (b <o> g) ? In other words : when the ouput of the first effectful function [f] may NOT be the same as the input of the subsequent effectful function [g] ? This is more complex than simply sequencing the effects , and shall be described in two steps . </p>

  <textarea id="workspace6">
  Variables (A_ A : Type) (a : A -> A_) (f : A -> B_ ).
  
(*
                   g
             B ------> C
             |
             . b
             |
             v
  A  ------> B_
  |    f
  . a
  |
  v
  A_

 *)

End section_reindexed_function.
</textarea>
<p>Here is the initial step. When the ouput of the first function is NOT the same as the input of the subsequent function , then the inputs of first function must be restricted/intersected such that the corresponding outputs of the first function fall within the input of the subsequent function .</p>

<p>The first function is "transported" ( "pullback" ) against the input of the subsequent function ; the restricted inputs of this transported first function is named "intersection" .</p>

<p>This transport process is the initial step and can be described on its own now , and the final step which is named transporting-composition will be described later .</p>

  <textarea id="workspace7">
Section section_intersection.

(*
              transported
intersection  ---------->   Multiples
 |                             |
 .                             . multiplier
 |                             |
 v                             v
 A -----------------------> Domain
               f
*)

  Variables (Domain : Type) (Multiples : Type) (multiplier : Multiples -> Domain) .

  Definition intersection (A : Type) (f : A -> Domain) : Type
    := { ab : ( A * Multiples ) |
         f ( fst ab ) = multiplier ( snd ab ) } . 

  Definition transported (A : Type) (f : A -> Domain) : intersection A f -> Multiples
    := fun ab_eq => snd (proj1_sig ab_eq) .

  Definition multimultiplier (A : Type) (f : A -> Domain) : intersection A f -> A
    := fun ab_eq => fst (proj1_sig ab_eq) .

  Definition multiplicity_of_intersection (A : Type) (f : A -> Domain) : intersection A f -> Domain
    := fun ab_eq => multiplier ( snd (proj1_sig ab_eq) ) .
End section_intersection.
</textarea>
<p>Memo : <em>this transport has both restriction flavor and multiplication flavor</em> ; nevertheless restriction can be viewed as exclusion via "multiplication by zero" , therefore multiplication is more general than restriction . </p>
<p>Example of multiplying the function [3] against the multiplier [2] .</p>

<p style="text-align:center;"><img width="100%" src="multiplied_intersection.svg"></p>

  <textarea id="workspace8">
Section section_intersection_example .
(*

   transported
...    |-->    . 
...    |-->    . 
               _
               | multiplier
               v
 
...    |-->    .
        f

 *)
  
  Inductive two : Type := Two1 : two | Two2 : two .
  Inductive three : Type := Three1 : three | Three2 : three | Three3 : three .
  Inductive infinite : Type := Start : infinite | Next : infinite -> infinite .

  Let Domain : Type := infinite.
  Let Multiples : Type := two.
  Let multiplier : Multiples -> Domain := fun m => (Next Start).
  Let A : Type := three.
  Let f : A -> Domain := fun a => (Next Start) .
  Compute ( transported Domain Multiples multiplier A f : {ab : three * two | (Next Start) = (Next Start)} -> two ) .
  Check fun ab_eq : {ab : three * two | (Next Start) = (Next Start)} =>
          let (_, b) := (let (ab, _) := ab_eq
                         in ab)
          in b .
End section_intersection_example.
</textarea>
<p>Here is the final step of composing two (general) reindexed functions . The transporting-composition makes use of the transport process to restrict/multiply the first effectful function [f] againt the input multiplier [b] of the subsequent function [g] ; then this transporting-composition simply composes their transported first effectful function [transp f] with the subsequent effectful function [g] to obtain [transp f o> g]. <p>
<p>  ( Moreover , if the input of the first function was somehow already restricted/multiplied via [a] , then this old restriction/multiplication [a] shall be composed/sequenced after the new restriction/multiplication [mult b] from this transport process ) </p>

  <textarea id="workspace9">
Section section_transporting_composition.
  Variables (A_ A : Type) (a : A -> A_) (B_ : Type) (f : A -> B_ ).
  Variables (B : Type) (b : B -> B_) (C : Type) (g : B -> C) .
  
(*

( a , f ) o> ( b , g )

                  g
             B ------> C
             |
             . b
             |
             v
  A  ------> B_
  |    f
  . a
  |
  v
  A_


 :=  ( a <o mult b , transp f o> g)

     transp f      g
  AB --------> B ------> C
   |  
   . mult b
   | 
   v 
   A 
   | 
   . a
   |
   v
   A_

*)

  Definition transporting_composition : ( intersection B_ B b A f -> A_ ) * ( intersection B_ B b A f -> C )
    := ( composition _ _ (multimultiplier B_ B b A f) _  a  , composition _ _ (transported B_ B b A f ) _  g  ) .
  
End section_transporting_composition.  
</textarea>
<p><b>The bottom line is : to compute/eliminate/normalize the transporting/pullback-composition is rephrasable/reducible as to compute/eliminate/normalize the (common) composition in the presence of transports/pullback ... </b></p>

<p><b>Dictionary.</b> What is the dictionary definition of "majority" ? <a href="https://www.thefreedictionary.com/majority">https://www.thefreedictionary.com/majority</a> says :</p>
<ul> <li> <i> The greater number or part; a number more than half <b>of the total</b>  </i> </li>
  <li> <i> the greater number or part <b>of something</b>  </i> </li>
  <li> <i> (elections) more than half <b>of the votes</b>  </i> </li>
</ul>

<p>The expression <b> "of ..." </b> refers to the <b>intersection</b> of the number with some explicitly totality/domain . The totality/domain is determined by such parameters as : space ( "where" ) , time ( "when" ) , end-goals ( "for what" ) .</p>

<p>Imagine that two counters in the number are mentality-neighbors ( same "where" , environment ) , or are synchronizing/colluding/conniving ( same "when" ) , or are interdependent ( same "for what" ) , then effectively/sensibly these two counters should merge as one counter , although formally/grammatically they are two distinct indexes for touching the same sensible counter . In short : it is possible to form/write the weighted (multiplied/fibered) intersection , as contrasted from effective/sensible majority ( which cancels-out multiplicity/"tribalism" ) ...</p>

<p><b>Legislation.</b> Each clause in some law/rule of the legislation may be viewed as determining more precisely some totality/domain of application . But is it possible to find therein or in practice such fools as "singleton-class" ?</p>

<p>In short : <b>"singleton-class" = </b> fabricating/falsifying some law/rule/grading/class which or its complement contains only some effectively-singleton target-individual , such to maximize this individual or correspondingly to obstruct this individual , or when the class becomes (unspoken) intersection-of-more-classes in the effective totality/domain and such is worse .</p>

<p>This last phrase says that the effective totality/domain may cause some hidden assumptions , such that the class becomes (unspoken) intersection-of-more-classes . The technical idea to express this situation is to say that : transporting some function against the identity function produces the same function . </p>

<textarea id="workspace10">
Section section_intersection_with_identity.
(*
         transp f == f
F /\ W ---------------------> W
   ^                          ^
   |                          |
   . id                       . id
   |                          |
   v                          v
   F  ----------------------> W
                 f
*)  
Lemma intersection_with_identity : forall F W : Prop , forall hidden : ( F -> W ) (* hidden assumption caused by the effective totality/domain *),
      ( ( F /\ W ) <-> F ) (* therefore the class F becomes (unspoken) intersection-of-more-classes *) .
Proof.
  intros F W hidden. split.
  - intros wf. destruct wf as [w f].
    + exact w.
  - intros f. split.
    + exact f .
    + exact (hidden f).
Qed.

End section_intersection_with_identity.
  </textarea>


<h2 class="title" id="live3">LIVE 3 : "maybe you are thief ?" is formally valid | BAD HUMAN VS COMPUTER |
  <br> FRIDAY 05 JULY 2019 AT 22:22 KST </h2>

  <p><b>Logic.</b> The ends is to describe how the inputs and outputs of some function may be formatted , and to discover that there are 4 equivalent alternative formatting/descriptions of <b> "formatted-function" </b> . The solution is : to rearrange and pair/separate the inputs or outputs such to produce many formats .
  </p>

  <p>The general reading is that in the diagram below : [ff] is formatted-function which is parametrized-over the reindexed-function [ ( a <o> f ) ] via the parametrizators [ ( a' , b' ) ] . The types at the top ( [A'] and [B'] ) contain the totality of the data or substance or "database records" . The types at the bottom ( [A_] and [B] and [A] ) contain the "partial information" and are "fields" / "projections" / "components" ( via [a'] and [b'] ) from the totality of the data . More precisely , the type [A] reindexes/reparametrizes the type [A_] ...
</p>

    <p>There are 4 equivalent alternative formatting/descriptions of "formatted-function" . The distinction is : how much the 3 inputs ( of type [A'] or [A] or [A_] ) are paired/grouped together ? The first format [formatted_NOPARAM] pairs/group all the inputs , and the other formats separate/decouple at least one input which becomes the parametrizator . The last format [formatted_INTERNAL_REPARAM] separate/ungroup all the inputs , the format [formatted_EXTERNAL] parametrizes some external function , the format [formatted_INTERNAL] parametrizes some internal function .
 </p>

  <p><em>Note : text edit this code by Alt+↑ , Alt+↓ , Alt+→ , Alt+⏎ , Alt+hover .</em></p>
  <textarea id="workspace11">
Section section_formatted_function.

(**

   ff : formatted
A'----------------> B'
|                   |
. a'                . b'
|                   |
.          f        v
| A --------------> B
. |
| . a
. |
v v
 A_

 *)
  
  Variables (A_ : Type) (A : Type) (a : A -> A_) (B : Type) (f : A -> B) .
  Variables (A' : Type) (a' : A' -> A_) (B' : Type) (b' : B' -> B) .

  Definition formatted_NOPARAM := forall x_x'_ : { x_x' : A * A' | a ( fst x_x' ) = a' ( snd x_x' ) } ,
      { y' : B' | f ( fst (proj1_sig x_x'_) ) = b' y' } .

  Definition formatted_EXTERNAL := forall x : A ,
      { x' : A' | a ( x ) = a' ( x' ) } -> { y' : B' | f ( x ) = b' y' } .
  
  Definition formatted_INTERNAL := forall x' : A' ,
      forall x_ : { x : A | a ( x ) = a' ( x' ) } , { y' : B' | f ( proj1_sig x_ ) = b' y' } .

  Definition formatted_INTERNAL_REPARAM := forall x0 : A_ ,
      { x' : A' | x0 = a' ( x' ) } -> forall x_ : { x : A | a ( x ) = x0 } , { y' : B' | f ( proj1_sig x_ ) = b' y' } .
  
  Lemma formatted_EXTERNAL_of_formatted_NOPARAM : formatted_NOPARAM -> formatted_EXTERNAL .
  Proof.
    unfold formatted_NOPARAM , formatted_EXTERNAL . intros ff . intros x x'_ . unshelve eexists.
    - refine (proj1_sig (ff _)).
      exists ( x , proj1_sig x'_ ).
      simpl. exact (proj2_sig x'_).
    - set ( x_x'_ := exist _ _ _ ). exact (proj2_sig (ff x_x'_)).
  Defined.

  Lemma formatted_INTERNAL_of_formatted_EXTERNAL : formatted_EXTERNAL -> formatted_INTERNAL .
  Proof.
    unfold formatted_EXTERNAL , formatted_INTERNAL . intros ff . intros x' x_ . unshelve eexists.
    - refine (proj1_sig (ff (proj1_sig x_) _)).
      exists x' .
      exact (proj2_sig x_).
    - set ( x'_ := exist _ _ _ ). exact (proj2_sig (ff (proj1_sig x_) x'_)).
  Defined.
  

  Lemma formatted_INTERNAL_REPARAM_of_formatted_INTERNAL : formatted_INTERNAL -> formatted_INTERNAL_REPARAM .
  Proof.
    unfold formatted_INTERNAL_REPARAM , formatted_INTERNAL . intros ff . intros x0 x'_ x_ . unshelve eexists.
    - refine (proj1_sig (ff (proj1_sig x'_) _)).
      exists (proj1_sig x_) .
      rewrite (proj2_sig x_) . rewrite <- (proj2_sig x'_). reflexivity.
    - set ( x__ := exist _ _ _ ). exact (proj2_sig (ff (proj1_sig x'_) x__)).
  Defined.

  Lemma formatted_NOPARAM_of_formatted_INTERNAL_REPARAM : formatted_INTERNAL_REPARAM -> formatted_NOPARAM .
  Proof.
    unfold formatted_INTERNAL_REPARAM , formatted_NOPARAM . intros ff . intros x_x'_ . unshelve eexists.
    - refine (proj1_sig (ff (a (fst (proj1_sig x_x'_))) _ _)).
      exists (snd (proj1_sig x_x'_)) . exact (proj2_sig x_x'_).
      exists (fst (proj1_sig x_x'_)) . reflexivity.
    - set ( x_ := exist _ _ _ ). set ( x'_ := exist _ _ _ ). 
      exact (proj2_sig (ff (a (fst (proj1_sig x_x'_))) x'_ x_)).
  Defined.

  (**NOT NECESSARY
  Lemma formatted_NOPARAM_of_formatted_INTERNAL : formatted_INTERNAL -> formatted_NOPARAM .
  Proof.
    unfold formatted_INTERNAL , formatted_NOPARAM . intros ff . intros x_x'_ . unshelve eexists.
    - refine (proj1_sig (ff (snd (proj1_sig x_x'_)) _)).
      exists (fst (proj1_sig x_x'_)) .
      exact (proj2_sig x_x'_).
    - set ( x_ := exist _ _ _ ). exact (proj2_sig (ff (snd (proj1_sig x_x'_)) x_)).
  Defined.
  
  Lemma formatted_INTERNAL_REPARAM_of_formatted_NOPARAM : formatted_NOPARAM -> formatted_INTERNAL_REPARAM .
  Proof.
    unfold formatted_INTERNAL_REPARAM , formatted_NOPARAM . intros ff . intros x0 x'_ x_ . unshelve eexists.
    - refine (proj1_sig (ff _)).
      exists ((proj1_sig x_) , (proj1_sig x'_)) .
      simpl. rewrite (proj2_sig x_) . rewrite <- (proj2_sig x'_). reflexivity.
    - set ( x_x'_ := exist _ _ _ ). 
      exact (proj2_sig (ff x_x'_)).
  Defined.
  **)
</textarea>
  <p>Below , internal function , whose internal input is of type [ { x : A | a ( x ) = x0 } ] ( or simply written [x0] ) , is similar as some tuple/pair/record whose sections/components may be accessed . Given some section , there are many equivalent alternatives for accessing this section : these accessors correspond to the many equivalent alternatives formats/descriptions for formatted-function . </p>

  <textarea id="workspace12">
  Definition internal_functions_at (x0 : A_ ) := forall x_ : { x : A | a ( x ) = x0 } , { y' : B' | f ( proj1_sig x_ ) = b' y' } .
  Check eq_refl _ : formatted_INTERNAL = forall x' : A' , internal_functions_at ( a' ( x' ) )  .
  Check eq_refl _ : formatted_INTERNAL_REPARAM = forall x0 : A_ ,
        { x' : A' | x0 = a' ( x' ) } -> internal_functions_at x0 .

  Section application_at_section.

(**

   ff : formatted
A'----------------> B'
|                   |
. a'                . b'
|                   |
.          f        v
| A --------------> B
. |  ^
| .  |
. |a |
| .  .
. |  |
| .  . section
v v  |
   A_

 *)
    
    Variables (section : A_ -> A) (section_ : forall x0 : A_ , a ( section x0 ) = x0 ).

    Definition application_at_section : forall (x0 : A_ ) , internal_functions_at x0 -> { y' : B' | f ( section x0 ) = b' y' }
      := fun x0 ff => (ff ( exist _ (section x0) (section_ x0) )).
   
    Axiom formatted_INTERNAL_REPARAM_property :
      forall ff : formatted_INTERNAL_REPARAM ,
       forall x0 : A_ , forall x'_ : { x' : A' | x0 = a' ( x' ) } , forall x_ : { x : A | a ( x ) = x0 } ,
             forall x00 : A_ , forall x'__ : { x' : A' | x00 = a' ( x' ) } , forall x__ : { x : A | a ( x ) = x00 } ,
                   x0 = x00 -> proj1_sig x'_ = proj1_sig x'__ -> proj1_sig x_ = proj1_sig x__ ->
                   proj1_sig (ff x0 x'_ x_) = proj1_sig (ff x00 x'__ x__) .

    Lemma compose_with_application_at_section :
      forall ff : formatted_INTERNAL_REPARAM, forall x0 : A_ ,
      forall x'_ : { x' : A' | x0 = a' ( x' ) } ,
        proj1_sig ( composition _ _ (ff x0) _ (application_at_section x0) x'_ )
        = proj1_sig ( (formatted_EXTERNAL_of_formatted_NOPARAM (formatted_NOPARAM_of_formatted_INTERNAL_REPARAM
                        ff )) (section x0) (exist (fun x' => a (section x0) = a' ( x' ))
                                           (proj1_sig x'_) ltac:(rewrite (section_ x0); exact (proj2_sig x'_))) ).
    Proof.
      intros. simpl. unfold composition , application_at_section. simpl.
      set (x_ := exist _ _ _).
      set (x'__ := exist _ _ _). set (x__ := exist _ _ _).
      eapply (formatted_INTERNAL_REPARAM_property ff x0 x'_ x_ (a (section x0)) x'__ x__).
      - rewrite section_. reflexivity.
      - reflexivity.
      - reflexivity.
    Defined.

  End application_at_section.
    
End section_formatted_function.
</textarea>

<p>The ends is to compose/sequence two formatted-functions when the formatted-output of the first formatted-function is not formatted as (included within) the formatted-input of the subsequent formatted-functiion . The solution is : to intersec the formatting of the input of the first formatted-function ( so that its output is formatted ) as the formatting of the input of the subsequent formatted-function . </p>

  <textarea id="workspace13">
Section section_formatted_function_composition.

(**
                       
            ff                    gg
 A' ------------------> B' ---------------> C'
 |                      |                   |
 .                      .                   .
 |                      |                   |
 .                      . b'                . c'
 |                      |                   |
 .                      .                   v
 | a'                   | B --------------> C
 .                      . |        g
 |                      | .  
 .                      . | b
 |                      | .
 .                      . |
 |                      v v
 . A ------------------> B_
 | |          f         
 . .                 
 | |                   
 . . a
 | |
 . .
 v v
  A_

 *)
  
  Variables (A_ : Type) (A : Type) (a : A -> A_) (B_ : Type) (f : A -> B_) .
  Variables (A' : Type) (a' : A' -> A_) (B' : Type) (b' : B' -> B_) .
  Variables (ff : formatted_EXTERNAL A_ A a B_ f A' a' B' b').
  Variables (B : Type) (b : B -> B_) (C : Type) (g : B -> C) .
  Variables (C' : Type) (c' : C' -> C) .
  Variables (gg : formatted_EXTERNAL B_ B b C g B' b' C' c').

  Lemma formatted_composition : formatted_EXTERNAL A_ (intersection B_ B b A f)
                                          (composition _ A (multimultiplier B_ B b A f) A_ a)
                                          C (composition _ _ (transported B_ B b A f) _ g)
                                          A' a' C' c' .
  Proof.
    unfold formatted_EXTERNAL , intersection , composition , multimultiplier , transported in * . intros x_y_ x'_ . unshelve eexists.
    - refine (proj1_sig (gg (snd (proj1_sig x_y_)) _ )). unshelve eexists.
      + refine (proj1_sig (ff (fst (proj1_sig x_y_)) _ )).
        exists (proj1_sig x'_) .
        exact (proj2_sig x'_).
      + rewrite <- (proj2_sig x_y_).
        set ( x'__ := exist _ _ _ ).  exact (proj2_sig (ff (fst (proj1_sig x_y_)) x'__)).
    - set ( ff_x'__ := exist _ _ _ ).  exact (proj2_sig (gg _ ff_x'__)).
  Defined.

End section_formatted_function_composition.
</textarea>

<p><b>Dictionary.</b> What is the dictionary definition of "format" / "form" ? <a href="https://www.thefreedictionary.com/format">https://www.thefreedictionary.com/format</a> , <a href="https://www.thefreedictionary.com/form">https://www.thefreedictionary.com/form</a> says : </p>
<ul> <li> <i> form - the <b>spatial arrangement</b> of something as distinct from its <b>substance</b> ; </i> </li>
  <li> <i> format - the <b>arrangement of data</b> for computer input or output, as the number of <b>fields</b> in a <b>database record</b> or the margins in a report ; </i> </li>
  <li> <i> form - a category of things distinguished by some <b>common characteristic</b> or quality ; </i> </li>
  <li> <i> format - the organization of information according to <b>preset specifications</b> (usually for computer processing) . </i> </li>
</ul>

<p>These key words "substance" , "data" , "database record" signify the "totality of the real data in memory" . But sometimes only some (preset) "partial information" ( "characteristic" , "specifications" , "field" / "projection" ) from this total data is "touched" / "indexing" ( for example for "spatial arrangement" ) .</p>

<p>What is the contrary/complement of "format" / "formal" / "grammatical" ? It is : "sense" ( "substance" , "data" ) in any other "possible forms" , and therefore may mention "discretion for the possibility" or "risk for the possibility" .  On the contrary : "format" is similar as "reference form" , "copy-me grading" , "objective" , which refuses to be subjective-under-teaching (of possible forms) .</p>

<p>Another manner in which "format" / "formal" is contrary to "sense" is : any declaration is formally valid when prefixed with "it is possible that ... " ( for example , "maybe you are thief" ) , but the inferred wanted sense is different from the lacking actual sense .</p>

<p>In summary : forced-fool-and-theft/lie/falsification has :</p>
<ul> <li> ( <b> "flip-flop" </b> ) , fool via : confused or by contradicting oneself , or by flip-flop « possibility » ( "discretion" , "risk" ) versus « copy-me grading » ( "format" , "CV" , "objective" , refuse to be subjective-under-teaching ) . </li>
<li> ( <b> "play-monopoly" </b> ) , fool via : by defame/accuse ( without personal-knowledge ) in the form of possibility/question-excuse ( " ... ? " , " maybe ... " ) . </li>
</ul>

<p><b>Legislation.</b> What is the legislation definition of "format" ?  <a href="https://www.canlii.org/en/on/laws/regu/rro-1990-reg-194/latest/rro-1990-reg-194.html#sec37.12.1">https://www.canlii.org/en/on/laws/regu/rro-1990-reg-194/latest/rro-1990-reg-194.html#sec37.12.1</a> , at "Rules of Civil Procedure, RRO 1990, Reg 194 / HEARING WITHOUT ORAL ARGUMENT / Opposed Motions in Writing" , says : </p>
<p> <i>37.12.1 (4) Where the issues of fact and law are not complex, the moving party may propose in the notice of motion that the motion be heard in writing without the attendance of the parties, in which case,</i>
<ul> <li> <i> (a) the motion shall be made on at least <b>fourteen days notice</b>; </i> </li>
  <li> <i> (b) the moving party shall serve with the notice of motion and immediately file, with proof of service in the court office where the motion is to be heard, <b>a motion record, a draft order and a factum</b> entitled factum for a motion in writing, setting out the moving party’s argument;  </i> </li>
  <li> <i> (c) the motion may be heard <b>in writing without the attendance of the parties</b>, unless the court orders otherwise. </i> </li>
</ul>
</p>

<p>Why would the <b> "oral format" </b> be contrasted from the <b> "written format" </b> ? The "partial information" which is touched is not same for these two formats ? </p>

<p>Indeed , in the oral format , the "bad party" will more easily confuse/mix up facts and falsify hidden presuppositions and indirectly suggest diffamatory/accusation possibilities/questions ( "frame" ) ; while the "real party" will more difficultly describe precisely the totality of the true reality , without mentioning/validating diffamatory/accusation possibilities/questions . </p>

<p>In contrast , the written format is always processed in advance ( "fourteen days notice" ) , has detailled description ( "a motion record, a draft order and a factum" ) which is not overwritten (masked/erased) by any confused-and-incomplete oral commentary ( "in writing without the attendance of the parties" ) .</p>

<h2 class="title" id="live4">LIVE 4 : to be continued ... </h2>

</div></div>
  </div> <!-- /#document -->
  </div> <!-- /#code-wrapper -->
  </div> <!-- /#ide-wrapper -->

  <script src="../../ui-js/jscoq-loader.js" type="text/javascript"></script>
  <script type="text/javascript">

    var jscoq_ids  = ['workspace1', 'workspace2' , 'workspace3' ,  'workspace4' ,  'workspace5',
    'workspace6', 'workspace7' , 'workspace8' ,  'workspace9' ,  'workspace10' ,
    'workspace11', 'workspace12' , 'workspace13' ];
    var jscoq_opts = {
        prelude:   true,
        base_path: '../../',
        init_pkgs: ['init', 'qoc'],
        all_pkgs:  ['init', 'qoc', 'coq-base', 'coq-collections', 'coq-arith', 'coq-reals', 'math-comp'],
        implicit_libs: true,
        editor: { mode: { 'company-coq': true }, keyMap: 'default' }
    };

    /* Global reference */
    var coq;

    loadJsCoq(jscoq_opts.base_path)
        .then( () => coq = new CoqManager(jscoq_ids, jscoq_opts) );
  </script>
</body>
</html>
