<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Initial</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Ubuntu" />
<link rel="stylesheet" type="text/css" href="./code/style.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Initial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd5bd6cc">1. Functions : functional-hold, delayed-substitution</a></li>
<li><a href="#org7d3fbf1">2. Data : class, constructor functions, destructor function</a>
<ul>
<li><a href="#orgb844805">2.1. Binary data</a></li>
<li><a href="#org8613805">2.2. Numbers data</a></li>
</ul>
</li>
<li><a href="#orgeba1148">3. Polymorphism : polymorphic data, polymorphic functions</a>
<ul>
<li><a href="#orgbefb84e">3.1. Option data</a></li>
<li><a href="#org00881cc">3.2. List data</a></li>
</ul>
</li>
<li><a href="#org6b5c68a">4. Classification</a>
<ul>
<li><a href="#org545010e">4.1. List classification</a></li>
<li><a href="#org6db58f1">4.2. Equality classification</a></li>
</ul>
</li>
<li><a href="#org54615d6">5. Deduction : functions</a>
<ul>
<li><a href="#org84df6f1">5.1. Goal as nested-stack</a></li>
<li><a href="#orgfd4ab6f">5.2. Intro from, apply in, specialize of, substitution by - the nested-stack</a></li>
<li><a href="#org3949414">5.3. Revert to, generalize in, unification of - the nested-stack</a>
<ul>
<li><a href="#org5f28321">5.3.1. revert</a></li>
<li><a href="#org4969822">5.3.2. generalize, unification-generalize</a></li>
<li><a href="#org5b7c93a">5.3.3. revert-then-intro</a></li>
<li><a href="#org4f563dd">5.3.4. equational-generalize</a></li>
<li><a href="#org002d1c4">5.3.5. lessorequal-generalize</a></li>
<li><a href="#org42368ef">5.3.6. initial-accumulator-generalize</a></li>
<li><a href="#org1aad7b2">5.3.7. forward-generalize, backward-generalize</a></li>
<li><a href="#orgfe326c7">5.3.8. weakening-generalize</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4c8e639">6. Deduction : data</a>
<ul>
<li><a href="#org8f25d05">6.1. inference</a></li>
<li><a href="#orgde10255">6.2. classifying inference</a></li>
<li><a href="#org259b9f1">6.3. alternative</a></li>
<li><a href="#org58b1a43">6.4. recursion</a></li>
</ul>
</li>
<li><a href="#org5343b48">7. Deduction : classification</a>
<ul>
<li><a href="#org6116e68">7.1. meta-computation</a></li>
<li><a href="#orgc5b14c7">7.2. boolean-computational reflection</a></li>
<li><a href="#org9b17275">7.3. boolean simultaneous-substitution</a></li>
<li><a href="#org3d7b767">7.4. recursion</a></li>
</ul>
</li>
<li><a href="#orgf9d80cf">8. Review of some long deductions</a>
<ul>
<li><a href="#orgd2c8b51">8.1. Accumulating division</a></li>
<li><a href="#org116e8b9">8.2. Review of OOO1337777</a></li>
</ul>
</li>
<li><a href="#orga8b5618">9. ConfusPlay</a>
<ul>
<li><a href="#org3bb20a0">9.1. ConfusPlay 1</a></li>
<li><a href="#org86b2750">9.2. ConfusPlay 2, refer ConfusPlay 1</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Initial view of some randomly-selected things in the <code>PROGRAMME</code> , which sometimes are
<span class="underline">generating instances</span> : instead of grammatically-describing some <i>general</i> class,
oneself sensibly-describes <i>one instance</i> of the class which is (almost-)generating
all the other instances of the class.
</p>

<div id="outline-container-orgd5bd6cc" class="outline-2">
<h2 id="orgd5bd6cc"><span class="section-number-2">1</span> Functions : functional-hold, delayed-substitution</h2>
<div class="outline-text-2" id="text-1">
<p>
Oneself lacks to write and solve the question
</p>

<pre class="example">
2 + 3
</pre>

<p>
In reality, oneself may want / lack to write and solve many such questions. Therefore
oneself may <span class="underline">hold</span> / <span class="underline">bind</span> some <span class="underline">name</span> / <span class="underline">identifier</span> such as <code>a</code> and <code>p</code> and write
the <span class="underline">functional-hold</span> / <span class="underline">function</span> ( "abstraction" )
</p>

<pre class="example">
fun p =&gt; fun a =&gt; a + p
</pre>

<p>
and then <span class="underline">(delay-)substitute</span> / <span class="underline">instantiate</span> / <span class="underline">apply</span> this single expression by many
<span class="underline">input</span> ( <span class="underline">outer</span> ) <span class="underline">parameter</span> <code>p</code> other than <code>3</code> and many <span class="underline">input</span> ( <span class="underline">inner</span> )
<span class="underline">argument</span> <code>a</code> other than <code>2</code>, and get <span class="underline">output</span> such as this <span class="underline">delayed-substitution</span>
( "application" )
</p>

<pre class="example">
(fun p =&gt; fun a =&gt; a + p) 3 2
</pre>

<p>
Does this solves the initial question ? What is the <span class="underline">motivation</span> ?
</p>

<p>
Primo, one motivation may be to memorize things. Therefore oneself may do some <span class="underline">outer</span>
programming / <span class="underline">commanding</span> of the <code>COQ</code> computer, and ( <span class="underline">top / globally</span> ) <span class="underline">behold</span> /
<span class="underline">define</span> some <span class="underline">name</span> / <span class="underline">identifier</span> <code>f</code> which <span class="underline">memorize</span> / <span class="underline">fold</span> / <span class="underline">shorten</span> some
common expressions such as :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">f</span> := <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">p</span> =&gt; <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">a</span> =&gt; a + p .
</pre>
</div>

<pre class="example">
[Loading ML file newring_plugin.cmxs ... done]
</pre>

<p>
Secondo, another motivation may be to <span class="underline">confirm</span> / <span class="underline">check</span> that whatever has been
memorized fulfill some prescribed/wanted <span class="underline">classification</span> / <span class="underline">property</span> /
<span class="underline">specification</span> / <span class="underline">type</span>, by doing <span class="underline">logical</span> <code>COQ</code> commands such as :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">f</span> : nat -&gt; nat -&gt; nat := <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">p</span> =&gt; <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">a</span> =&gt; a + p .
</pre>
</div>

<pre class="example">
f is defined
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> f.
</pre>
</div>

<pre class="example">
f
     : nat -&gt; nat -&gt; nat
</pre>

<p>
in contrast to, which is false,
</p>

<pre class="example">
Definition f : nat -&gt; nat -&gt; bool := fun p =&gt; fun a =&gt; a + p .
</pre>

<pre class="example">
Toplevel input, characters 55-60:
&gt; Definition f : nat -&gt; nat -&gt; bool := fun p =&gt; fun a =&gt; a + p .
&gt;                                                        ^^^^^
Error:
In environment
p : nat
a : nat
The term "a + p" has type "nat" while it is expected to have type "bool".
</pre>

<p>
where <code>nat</code> is the more primitive class <code>0 | 1 | 2 | 3 | ...</code> and <code>bool</code> is the more
primitive class <code>true | false</code> and <code>nat -&gt; nat -&gt; nat</code> is some more composite class
which iterates two <span class="underline">function class former</span> ( <span class="underline">inference</span> <code>.. -&gt; ..</code> or <span class="underline">classifying
inference</span> / <span class="underline">quantification</span> <code>forall .. , ..</code> ) such to classify such functions.
</p>

<p>
In short : whenever assuming <code>(x : A)</code> ( <code>x</code> is some identifier classified by the
class <code>A</code> ) one has <code>(b : B)</code> ( <code>b</code> is some term classified by the classification <code>B</code>
), &#x2026;  therefore one may (introduce <code>forall</code> by) <i>form</i> this term and its
classification <code>((fun x : A =&gt; b) : (forall x : A, B))</code> , also written <code>((fun x : A =&gt;
b) : (A -&gt; B))</code> when the identifier <code>x</code> does not occur/mentionned in the textual
description of <code>B</code>. This process is named <span class="underline">functional-holding</span> / <span class="underline">functional-binding</span>
/ <span class="underline">discharge</span>.
</p>

<p>
And in the absence of some prescribed/wanted classification or in the presence of only
partial classification, the <code>COQ</code> computer will attempt to <span class="underline">infer</span> some full
classification whenever possible. This inference may fail because the given expression
is non classifiable or the prescribed/wanted classification is not contained/subclass
of some possible inferred classification.
</p>

<p>
Tertio, another motivation may be to get the output in some more primitive
<span class="underline">resolution</span> / <span class="underline">value</span> / <span class="underline">normal form</span>, by doing <span class="underline">computational</span> <code>COQ</code> commands such
as :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> f 3 2.
</pre>
</div>

<pre class="example">
= 5
: nat
</pre>

<p>
In short : whenever <code>(f : forall x : A, B)</code> ( <code>f</code> is some term formed as above ) and
<code>(t : A)</code> ( <code>t</code> is some term classified by the class <code>A</code> ), &#x2026; therefore one may
(eliminate <code>forall</code> by) <i>form</i> this term and its classification <code>((f t) : B[t/x])</code>,
where <code>(B[t/x])</code> signifies the substitution of <code>t</code> for <code>x</code> in the textual description
of <code>B</code>, also written <code>((f t) : B)</code> when the identifier <code>x</code> does not occur/mentionned
in the textual description of <code>B</code>. This process is named <span class="underline">delayed-substitution</span> /
<span class="underline">application</span>.
</p>

<p>
Finally, other <code>COQ</code> commands query the present memory of the <code>COQ</code> computer, such
as :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> f.
</pre>
</div>

<pre class="example">
f : nat -&gt; nat -&gt; nat

Argument scopes are [nat_scope nat_scope]
f is transparent
Expands to: Constant Top.f
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> f.
</pre>
</div>

<pre class="example">
f = fun p : nat =&gt; addn^~ p
     : nat -&gt; nat -&gt; nat

Argument scopes are [nat_scope nat_scope]
</pre>

<div class="org-src-container">
<pre class="src src-coq">Reset f.
</pre>
</div>

<pre class="example">
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> f.
</pre>
</div>

<pre class="example">
f not a defined object.
</pre>

<p>
<i>From the angle of view that computers is the "foundations" of mathematics, one may
not delay too much on the mathematical "foundations" of the <code>COQ</code> computer.</i>
</p>
</div>
</div>

<div id="outline-container-org7d3fbf1" class="outline-2">
<h2 id="org7d3fbf1"><span class="section-number-2">2</span> Data : class, constructor functions, destructor function</h2>
<div class="outline-text-2" id="text-2">
<p>
Oneself may want to <span class="underline">classify</span> / <span class="underline">type</span> some data, for example : classify <code>true |
false</code> together and name it <code>bool</code> ( or <code>bin</code> ) ; classify <code>1 | 2 | 3 | ...</code> together
and name it <code>nat</code> &#x2026;
</p>

<p>
Primo, one shall say <span class="underline">alternatives</span> / <span class="underline">cases</span> to (recursively) <span class="underline">construct</span> / <span class="underline">build</span>
data in this class. Each alternative is described by some <span class="underline">constructor function</span> which
always output into this class. Moveover this constructor function may (recursively)
take input from this class. The terminology <span class="underline">constructor constant</span> is used in the
instance that this constructor function does not take any input.
</p>

<p>
Secondo, one shall say that these given alternate constructions <span class="underline">computationally or
logically fulfill</span> / <span class="underline">support</span> this class, which is that it is sufficient to focus /
touch on these (recursively) constructored data when holding this class, which is that
any (random) data in the class may be such (recursively) <span class="underline">destructed</span> / <span class="underline">eliminated</span> /
<span class="underline">matched</span> / <span class="underline">filtered</span>. This is described by one (grammatical) <span class="underline">destructor / match
function</span> which always input from this class.
</p>
</div>

<div id="outline-container-orgb844805" class="outline-3">
<h3 id="orgb844805"><span class="section-number-3">2.1</span> Binary data</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The name of the two constructors are <code>true</code> and <code>false</code> , and the name of the class
/ type is <code>bool</code> ; and this is how to command <code>COQ</code> to memorize such names :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">bool</span> := true : bool | false : bool.
</pre>
</div>

<pre class="example">
bool is defined
</pre>

<p>
And <code>COQ</code> defines and memorize additional names <code>bool_rect</code> , <code>bool_ind</code> , <code>bool_rec</code>
which are easier decoration shortening of the more primitive same (grammatical)
<span class="underline">destructor / match function</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> bool_rect.
</pre>
</div>

<pre class="example">
bool_rect = 
fun (P : bool -&gt; Type) (f : P true) (f0 : P false) (b : bool) =&gt;
if b as b0 return (P b0) then f else f0
     : forall P : bool -&gt; Type, P true -&gt; P false -&gt; forall b : bool, P b

Argument scopes are [function_scope _ _ bool_scope]
</pre>

<p>
which says as expected that these given <code>true | false</code> alternate constructions
<span class="underline">computationally or logically fulfill</span> / <span class="underline">support</span> this class <code>bool</code> &#x2026; Some instance
of this same <code>match</code> destruction / filtering / elimination function, using shorter
grammar, is :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> (<span style="font-weight: bold; text-decoration: underline;">if</span> true <span style="font-weight: bold; text-decoration: underline;">then</span> 3 <span style="font-weight: bold; text-decoration: underline;">else</span> 2) .
</pre>
</div>

<pre class="example">
if true then 3 else 2
     : nat
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> ((<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">b</span> : bool =&gt; (<span style="font-weight: bold; text-decoration: underline;">if</span> b <span style="font-weight: bold; text-decoration: underline;">then</span> 3 <span style="font-weight: bold; text-decoration: underline;">else</span> 2)) false) .
</pre>
</div>

<pre class="example">
= 2
: nat
</pre>

<p>
The <code>PROGRAMME</code> contains some collection of binary / boolean operations that mirror
reasoning steps on truth values. The functions are named <code>negb</code> ( <span class="underline">negation</span> ) , <code>orb</code>
( <span class="underline">orelse</span> ) , <code>andb</code> ( <span class="underline">andthen</span> ), <code>implyb</code> ( <span class="underline">branch</span> ), correspondingly with
notations <code>~~</code> , <code>||</code> , <code>&amp;&amp;</code> , and <code>==&gt;</code> . The first operator is <span class="underline">prefix</span> (non
left-recursive parsing) parsed as in <code>~~ b</code> , the last three operators are <span class="underline">no-prefix</span>
( <span class="underline">infix</span> ) parsed as in <code>b1 &amp;&amp; b2</code> .
</p>

<p>
For instance, the function <code>andb</code> ouputs true the-same-as [ the first input is true
andthen the second input is true ] :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">andb</span> b1 b2 := <span style="font-weight: bold; text-decoration: underline;">if</span> b1 <span style="font-weight: bold; text-decoration: underline;">then</span> b2 <span style="font-weight: bold; text-decoration: underline;">else</span> false.
</pre>
</div>
</div>
</div>

<div id="outline-container-org8613805" class="outline-3">
<h3 id="org8613805"><span class="section-number-3">2.2</span> Numbers data</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Any number is zero or the successor of an existing number :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">nat</span> := 
    O : nat 
  | S : nat -&gt; nat.
</pre>
</div>

<pre class="example">
nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined
</pre>

<p>
This command says that the only ways to produce numbers are by using the constant
<span class="underline">symbol</span> / <span class="underline">sign</span> / <span class="underline">token</span> <code>O</code> ( capital « o » letter, to represent <code>0</code> ), or by
applying the function symbol <code>S</code> to some already existing number. In other words, <code>O</code>
is some number, <code>(S O)</code> is some number, <code>(S (S O))</code> , and so on, and these are the
only numbers.
</p>

<p>
And <code>COQ</code> defines and memorize additional names <code>nat_rect</code> , <code>nat_ind</code> , <code>nat_rec</code>
which are easier decoration shortening of the more primitive same (grammatical)
<span class="underline">destructor/match function</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> nat_rect.
</pre>
</div>

<pre class="example">
nat_rect = 
fun (P : nat -&gt; Type) (f : P 0) (f0 : forall n : nat, P n -&gt; P n.+1) =&gt;
fix F (n : nat) : P n :=
  match n as n0 return (P n0) with
  | 0 =&gt; f
  | n0.+1 =&gt; f0 n0 (F n0)
  end
     : forall P : nat -&gt; Type,
       P 0 -&gt; (forall n : nat, P n -&gt; P n.+1) -&gt; forall n : nat, P n

Argument scopes are [function_scope _ function_scope nat_scope]
</pre>

<p>
which says as expected that these given <code>O | S (n : nat)</code> alternate constructions
<span class="underline">computationally or logically fulfill</span> / <span class="underline">support</span> this class <code>nat</code> &#x2026; One shall
clarify why this <code>fix</code> keytext for <code>nat</code> ( instead of the ealier only <code>fun</code> keytext
for <code>bool</code> ) later.
</p>

<p>
When interacting with <code>COQ</code>, oneself will often see decimal notations ( <code>0</code> <code>1</code> <code>2</code>
<code>3</code> <code>4</code> &#x2026; ), but these are only some parsing and printing / display facility
provided to the programmer for readability. In other words <code>O</code> is printed <code>0</code> , <code>(S
O)</code> is printed <code>1</code> , <code>(S (S O))</code> is printed <code>2</code> &#x2026; Programmers may also write decimal
numbers to describe values, but these are automatically parsed into terms built with
<code>O</code> and <code>S</code>.
</p>

<p>
Also, the <span class="underline">postfix</span> (infix) <code>x.+1</code> notation is translated as the prefix expression <code>S
x</code> . The <code>.+1</code> notation binds more strongly (at level 2) than function application (at
level 10). Attempt :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> Grammar constr.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">x</span> =&gt; (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">n</span> : nat =&gt; n) x.+1 .
<span style="font-weight: bold;">Locate</span> <span style="font-style: italic;">".+1"</span> .
</pre>
</div>

<pre class="example">
fun x : nat =&gt; id x.+1
     : nat -&gt; nat
</pre>

<p>
When computing functions over number input data or deducting lemmas over number
subject data, oneself may proceed by touching only the alternative cases form of the
data, and therefore by the minimality / inductive / elimination for <code>nat</code> , the
function or deduction will be indeed over all numbers. For example here is the
definition of « beheading <code>S</code> » ( predecessor ) for numbers :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">pred</span> n := 
  <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span> 
    O =&gt; O 
  | S t =&gt; t 
  <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<p>
The <span class="underline">branch</span> <code>O =&gt; O</code> says that when <code>n</code> has the alternative zero form <code>O</code> then the
whole expression is transformed to <code>O</code> ; here the left <code>O</code> is some <span class="underline">filter</span> /
<span class="underline">pattern</span> and the computation decides whether <code>n</code> <span class="underline">matches</span> this pattern. The branch
<code>S t =&gt; t</code> says that when <code>n</code> has the alternative successor form <code>S t</code> then <code>t</code> is
instantiated/bound by this subterm (tail) of <code>n</code> and the whole expression is
transformed to <code>t</code> ; here <code>S t</code> is some filter / pattern containing one named
<span class="underline">filter-identifier</span> / <span class="underline">filter-variable</span> <code>t</code> and the computation decides whether <code>n</code>
matches this pattern.
</p>

<p>
Each constructor must be covered by some branch and by at most one branch. For
example, this attempt is not memorized by the <code>COQ</code> computer :
</p>

<div class="org-src-container">
<pre class="src src-coq">Fail <span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">wrong</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) :=
<span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span> 0 =&gt; true <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<pre class="example">
The command has indeed failed with message:
Non exhaustive pattern-matching: no clause found for pattern 
_.+1
</pre>

<p>
Memo that the <code>COQ</code> (outer) parser and printer ( <code>CAMLP5</code> ) may prevent programmer
fatigue and translate the grammar
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">sameOn_bool_nat</span> b n :=
  <span style="font-weight: bold; text-decoration: underline;">match</span> b, n <span style="font-weight: bold; text-decoration: underline;">with</span>
    | true, S _ =&gt; true
    | _, _ =&gt; false
  <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<p>
as the same as
</p>

<div class="org-src-container">
<pre class="src src-coq">Reset sameOn_bool_nat.
<span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">sameOn_bool_nat</span> b n :=
  <span style="font-weight: bold; text-decoration: underline;">match</span> b <span style="font-weight: bold; text-decoration: underline;">with</span>
    | true =&gt; <span style="font-weight: bold; text-decoration: underline;">if</span> n <span style="font-weight: bold; text-decoration: underline;">is</span> S t <span style="font-weight: bold; text-decoration: underline;">then</span> true <span style="font-weight: bold; text-decoration: underline;">else</span> false
    | _ =&gt; false
  <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<p>
Now some clarification for the <code>fix</code> keytext. When computing functions over number
input data or deducting lemmas over number subject data, oneself may transform the
input arguments to the function or lemma into some other input arguments for the
<i>same</i> function or lemma. The keytext <code>fix</code> says that the same function name may be
mentioned. For example here is the definition of concatenation (addition) for
numbers :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span>
  <span style="font-weight: bold; text-decoration: underline;">fix</span> add n m := 
    <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span>
      S t =&gt; add t (S m)
      | O =&gt; m
    <span style="font-weight: bold; text-decoration: underline;">end</span> .
</pre>
</div>

<pre class="example">
fix add (n m : nat) {struct n} : nat :=
  match n with
  | 0 =&gt; m
  | t.+1 =&gt; add t m.+1
  end
     : nat -&gt; nat -&gt; nat
</pre>

<p>
Memo that one of the <span class="underline">inner memories</span> / <span class="underline">accumulators</span> <code>n</code> and <code>m</code> shall be
<span class="underline">degrading</span> / <span class="underline">decreasing</span> / <span class="underline">structural</span> / <span class="underline">terminating</span>, here it is the accumulator
<code>n</code> which is decreasing ( structural, <code>{struct n}</code> ). And the <code>COQ</code> computer is very
good at detecting when something is degrading, otherwise there are many other
techniques to solves this question of termination &#x2026;
</p>

<p>
Now instead of using two (inner) accumulators <code>n</code> and <code>m</code> , oneself may want to use :
</p>
<ul class="org-ul">
<li>only one inner accumulator <code>n</code> , together with</li>
<li><span class="underline">pending</span> (outer) effects / computations ( the <code>S</code> surrounding <code>(add t)</code> ) instead
of changing some second inner memory, together with</li>
<li>one <span class="underline">outer parameter</span> <code>p</code> which is <i>not changed</i> as memory during computation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> 
  <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">p</span> =&gt; <span style="font-weight: bold; text-decoration: underline;">fix</span> add n := 
    <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span>
      S t =&gt; S (add t)
      | O =&gt; p
    <span style="font-weight: bold; text-decoration: underline;">end</span> .
</pre>
</div>

<pre class="example">
fun p : nat =&gt;
fix add (n : nat) : nat := match n with
                           | 0 =&gt; p
                           | t.+1 =&gt; (add t).+1
                           end
     : nat -&gt; nat -&gt; nat
</pre>

<p>
Finally oneself may command <code>COQ</code> to memorize this expression :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">add</span> := 
  <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">p</span> =&gt; <span style="font-weight: bold; text-decoration: underline;">fix</span> add n := 
    <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span>
      S t =&gt; S (add t)
      | O =&gt; p
    <span style="font-weight: bold; text-decoration: underline;">end</span> .
</pre>
</div>

<pre class="example">
add is defined
</pre>

<p>
To prevent programmer fatigue, <code>COQ</code> has some alias command <code>Fixpoint</code> which does
<i>almost the same</i> thing :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Fixpoint</span> <span style="font-weight: bold;">add</span> p n {<span style="font-weight: bold; text-decoration: underline;">struct</span> n} := 
    <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span>
      S t =&gt; S (add p t)
      | O =&gt; p
    <span style="font-weight: bold; text-decoration: underline;">end</span> .
<span style="font-weight: bold;">Print</span> add.
</pre>
</div>

<pre class="example">
add is defined
add is recursively defined (decreasing on 2nd argument)

add = 
fix add (p n : nat) {struct n} : nat :=
  match n with
  | 0 =&gt; p
  | t.+1 =&gt; (add p t).+1
  end
     : nat -&gt; nat -&gt; nat

Argument scopes are [nat_scope nat_scope]
</pre>

<p>
or <code>COQ</code> has some combination of the <code>Section</code> command with the <code>Fixpoint</code> command
which does <i>precisely the same</i> thing, because the <code>Section</code> process is for holding /
binding <span class="underline">(outer) parameters / variables</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Section</span> <span style="font-weight: bold;">Section1</span>.
  <span style="font-weight: bold;">Variable</span> <span style="font-weight: bold; font-style: italic;">p</span> : nat.
  <span style="font-weight: bold;">Fixpoint</span> <span style="font-weight: bold;">add</span> n := 
      <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span>
        S t =&gt; S (add t)
        | O =&gt; p
      <span style="font-weight: bold; text-decoration: underline;">end</span> .
<span style="font-weight: bold;">End</span> <span style="font-weight: bold;">Section1</span>.
<span style="font-weight: bold;">Print</span> add.
</pre>
</div>

<pre class="example">
p is declared

add is defined
add is recursively defined (decreasing on 1st argument)


add = 
fun p : nat =&gt;
fix add (n : nat) : nat := match n with
                           | 0 =&gt; p
                           | t.+1 =&gt; (add t).+1
                           end
     : nat -&gt; nat -&gt; nat

Argument scopes are [nat_scope nat_scope]
</pre>

<div class="org-src-container">
<pre class="src src-coq">Reset Section1.
</pre>
</div>

<pre class="example">
</pre>

<p>
Little reminder : the <code>PROGRAMME</code> defines instead some function <code>addn</code> such that <code>addn
n p</code> is <code>add p n</code> ( this latest <code>add</code> of <code>Section1</code> ) &#x2026; Moreover the <code>PROGRAMME</code>
defines addition ( named <code>addn</code> , infix notation <code>+</code> ), predecessor ( <code>predn</code> ,
postfix notation <code>.-1</code> ), doubling ( <code>doublen</code> , postfix notation <code>.*2</code> ),
multiplication ( <code>muln</code> , infix notation <code>*</code> ), subtraction ( <code>subn</code> , infix notation
<code>-</code> ), division ( <code>divn</code> , infix notation <code>%/</code> ), modulo ( <code>modn</code> , infix notation
<code>%%</code> ), exponentiation ( <code>expn</code> , infix notation <code>^</code> ), equality comparison ( <code>eqn</code> ,
infix notation <code>==</code> ), and order comparison ( <code>leq</code> , infix notation <code>&lt;=</code> ) on
(natural) numbers.
</p>

<p>
Many of these functions may be defined by reusing the general function <code>iter</code>, which
is the iterator over any number in <code>nat</code> , or by reusing the more-general function
<code>foldr</code> , which is the iterator over any list in <code>seq</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> iter.
<span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">add</span> (<span style="font-weight: bold; font-style: italic;">p</span> : nat) : nat -&gt; nat :=
  <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">n</span> : nat =&gt;
    iter n (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">acc</span> : nat =&gt; S (acc)) p .
<span style="font-weight: bold;">Print</span> foldr.
</pre>
</div>

<pre class="example">
iter = 
fun (T : Type) (n : nat) (f : T -&gt; T) (x : T) =&gt;
let fix loop (m : nat) : T := match m with
                              | 0 =&gt; x
                              | i.+1 =&gt; f (loop i)
                              end in
loop n
     : forall T : Type, nat -&gt; (T -&gt; T) -&gt; T -&gt; T

Argument T is implicit
Argument scopes are [type_scope nat_scope function_scope _]

add is defined

foldr = 
fun (T R : Type) (f : T -&gt; R -&gt; R) (z0 : R) =&gt;
fix foldr (s : seq T) : R :=
  match s with
  | [::] =&gt; z0
  | x :: s' =&gt; f x (foldr s')
  end
     : forall T R : Type, (T -&gt; R -&gt; R) -&gt; R -&gt; seq T -&gt; R

Arguments T, R are implicit and maximally inserted
Argument scopes are [type_scope type_scope function_scope _ seq_scope]
</pre>

<p>
Elsewhere, as expected because of the <i>some-accumulator-is-decreasing requirement</i>,
this attempt is not memorized by the <code>COQ</code> computer :
</p>

<div class="org-src-container">
<pre class="src src-coq">Fail
<span style="font-weight: bold;">Fixpoint</span> <span style="font-weight: bold;">nat_empty</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) {<span style="font-weight: bold; text-decoration: underline;">struct</span> n}: <span style="font-weight: bold; text-decoration: underline;">False</span> := 
  <span style="font-weight: bold; text-decoration: underline;">if</span> n <span style="font-weight: bold; text-decoration: underline;">is</span> S n' <span style="font-weight: bold; text-decoration: underline;">then</span> nat_empty n' <span style="font-weight: bold; text-decoration: underline;">else</span> nat_empty 0.
Fail <span style="font-weight: bold;">Check</span> nat_empty ( <span style="font-weight: bold; font-style: italic;">3</span> : nat ) <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">: False *</span><span style="font-weight: bold; font-style: italic;">*)</span>.
</pre>
</div>

<pre class="example">
The command has indeed failed with message:
Recursive definition of nat_empty is ill-formed.
In environment
nat_empty : nat -&gt; False
n : nat
Recursive call to nat_empty has principal argument equal to 
"0" instead of a subterm of "n".
Recursive definition is:
"fun n : nat =&gt; match n with
                | 0 =&gt; nat_empty 0
                | n'.+1 =&gt; nat_empty n'
                end".

The command has indeed failed with message:
The reference nat_empty was not found in the current environment.
</pre>

<p>
where <code>False</code> is the <span class="underline">empty class / nat</span>. Indeed <code>nat_empty : nat -&gt; False</code> would say
that the class <code>nat</code> is <i>empty</i> when in reality the class <code>nat</code> does contain the data
element <code>3</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgeba1148" class="outline-2">
<h2 id="orgeba1148"><span class="section-number-2">3</span> Polymorphism : polymorphic data, polymorphic functions</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgbefb84e" class="outline-3">
<h3 id="orgbefb84e"><span class="section-number-3">3.1</span> Option data</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Now oneself wants some version of the data type <code>bool</code> which is <span class="underline">container</span> for
more information / data, which is that each alternative <code>true | false</code> may contain
more data which says <i>how</i> true (or how false).
</p>

<p>
Suppose oneself wants to write this partial function over only the <i>odd</i> numbers :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">pred_for_only_odd</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) := <span style="font-weight: bold; text-decoration: underline;">if</span> odd n <span style="font-weight: bold; text-decoration: underline;">then</span> Some (n.-1) <span style="font-weight: bold; text-decoration: underline;">else</span> None.
</pre>
</div>

<p>
or suppose oneself wants to write such partial function over only the <i>small</i>
numbers :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">odd_for_only_small</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) := <span style="font-weight: bold; text-decoration: underline;">if</span> n &lt; 100 <span style="font-weight: bold; text-decoration: underline;">then</span> Some (odd n) <span style="font-weight: bold; text-decoration: underline;">else</span> None.
</pre>
</div>

<p>
Therefore one may define some <span class="underline">outer parametric /_polymorphic data type</span> as such :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">option</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) := None : option A | Some : A -&gt; option A.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> option.
<span style="font-weight: bold;">About</span> None.
<span style="font-weight: bold;">About</span> Some.
</pre>
</div>

<pre class="example">
option : Type -&gt; Type

option is template universe polymorphic
Argument scope is [type_scope]
Expands to: Inductive Coq.Init.Datatypes.option

None : forall A : Type, option A

None is template universe polymorphic
Argument A is implicit and maximally inserted
Argument scope is [type_scope]
Expands to: Constructor Coq.Init.Datatypes.None

Some : forall A : Type, A -&gt; option A

Some is template universe polymorphic
Arguments are renamed to A, a
Argument A is implicit and maximally inserted
Argument scopes are [type_scope _]
Expands to: Constructor Coq.Init.Datatypes.Some
</pre>

<p>
The <span class="underline">parameter</span> <code>A</code> says that some different type / class <code>(option A)</code> exists for each
possible choice of some type / class <code>A</code> , for example <code>(option nat)</code> , <code>(option
bool)</code> &#x2026; And <code>Type</code> is some keytext / keyword that denotes <span class="underline">the class of all data
classes</span>, and <code>option</code> is some <span class="underline">class / type former</span> function, itself of class <code>(Type
-&gt; Type)</code>. Indeed <code>option</code> alone is not some data-type, but if oneself instantiates it
with another data type, then it forms one.  For example <code>(nat : Type)</code> and <code>(bool :
Type)</code> are of class <code>Type</code>, and may be used in place of <code>A</code> to produce the types
<code>((option nat) : Type)</code> and <code>((option bool) : Type)</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> pred_for_only_odd : nat -&gt; option nat.
<span style="font-weight: bold;">Check</span> odd_for_only_small : nat -&gt; option bool.
</pre>
</div>

<p>
Memo that all the constructors of this polymorphic data type definition, in reality,
have some type parameter, where as described in some section above, the <i>classifying
inference</i> keytext <code>forall .. , ..</code> is some more general form of the <i>inference</i>
keytext <code>.. -&gt; ..</code> .
</p>

<p>
The message <code>Argument A is implicit and ...</code> says that every time programmers write
<code>Some</code> or <code>None</code> , the <code>COQ</code> computer automatically inserts / instantiates some term
in place of the parameter <code>A</code> , such that this term does not lack to be textually
written : the parameter is <span class="underline">hidden</span> / <span class="underline">implicit</span>. And the <code>COQ</code> computer <span class="underline">infers</span> or
guesses whatever-is this type parameter
</p>
<ul class="org-ul">
<li>when looking at the first explicit argument input given to <code>Some</code> , or</li>
<li>when looking at the context surrounding the ouput of <code>None</code> .</li>
</ul>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> Some 2.
</pre>
</div>

<pre class="example">
Some 2
     : option nat
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> <span style="font-weight: bold; text-decoration: underline;">if</span> (37 + 73) &lt; 100 <span style="font-weight: bold; text-decoration: underline;">then</span> Some (37+73) <span style="font-weight: bold; text-decoration: underline;">else</span> None.
<span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> <span style="font-weight: bold; text-decoration: underline;">if</span> (37 + 73) &lt; 100 <span style="font-weight: bold; text-decoration: underline;">then</span> Some (odd (37 + 73)) <span style="font-weight: bold; text-decoration: underline;">else</span> None.
Fail <span style="font-weight: bold;">Check</span> <span style="font-weight: bold; text-decoration: underline;">if</span> (37 + 73) &lt; 100 <span style="font-weight: bold; text-decoration: underline;">then</span> Some (odd (37 + 73)) <span style="font-weight: bold; text-decoration: underline;">else</span> (None (A := nat)).
Fail <span style="font-weight: bold;">Check</span> <span style="font-weight: bold; text-decoration: underline;">if</span> (37 + 73) &lt; 100 <span style="font-weight: bold; text-decoration: underline;">then</span> Some (odd (37 + 73)) <span style="font-weight: bold; text-decoration: underline;">else</span> (@None nat).
<span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> <span style="font-weight: bold; text-decoration: underline;">if</span> (37 + 73) &lt; 100 <span style="font-weight: bold; text-decoration: underline;">then</span> Some (odd (37 + 73)) <span style="font-weight: bold; text-decoration: underline;">else</span> @None _.
</pre>
</div>

<pre class="example">
if 37 + 73 &lt; 100 then Some (37 + 73) else None
     : option nat

     = None
     : option bool

The command has indeed failed with message:
The term "None" has type "option nat" while it is expected to have type
 "option bool".

The command has indeed failed with message:
The term "None" has type "option nat" while it is expected to have type
 "option bool".
</pre>

<p>
This example shows that the grammar <code>(None (A := nat))</code> or <code>(@None nat)</code> may be used
to force or input explicitly some parameter which is hidden, and that the grammar <code>_</code>
(underline, filter, hole, wildcard) as in <code>@None _</code> may be used to explicitly-command
<code>COQ</code> to attempt to infer some instantiation of any (implicit or explicit) parameter
<code>A</code>, for many reasons &#x2026; In reality, the message <code>Argument A ... and maximally
inserted</code> says that whenever the programmer writes <code>None</code> , the <code>COQ</code> computer
translates it to <code>@None _</code>.
</p>
</div>
</div>

<div id="outline-container-org00881cc" class="outline-3">
<h3 id="org00881cc"><span class="section-number-3">3.2</span> List data</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Now oneself wants some version of the data type <code>nat</code> which is <span class="underline">container</span> for more
information / data, which is that each alternative <code>O | S (n : nat)</code> may contain more
data which says <i>how</i> successor (or how zero). This is precisely the <code>polymorphic list
/ seq type</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">seq</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) := nil : seq A | cons : A -&gt; seq A -&gt; seq A.
</pre>
</div>

<p>
This polymorphic data type may indeed be instantiated to contain booleans <code>(seq bool)</code>
or be instantiated to contain numbers <code>(seq nat)</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> cons true (cons false (cons true nil)).
<span style="font-weight: bold;">Check</span> cons 2 (cons 1 (cons 3 nil)).
<span style="font-weight: bold;">Check</span> 2 :: 1 :: 3 :: nil.
<span style="font-weight: bold;">Check</span> [:: 2; 1; 3].
<span style="font-weight: bold;">Check</span> <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">l</span> : seq nat =&gt; [:: 2, 1, 3 &amp; l].
</pre>
</div>

<pre class="example">
[:: true; false; true]
     : seq bool

[:: 2; 1; 3]
     : seq nat

[:: 2; 1; 3]
     : seq nat

[:: 2; 1; 3]
     : seq nat

fun l : seq nat =&gt; [:: 2, 1, 3 &amp; l]
     : seq nat -&gt; seq nat
</pre>

<p>
In addition to the common functions which <i>precisely-inspect</i> the input, oneself may
write <span class="underline">polymorphic functions</span> which <i>only-touch the form</i> of the input. For example
oneself may write one single function which compute the number form (size) of any list
(booleans list or numbers list or else) :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Fixpoint</span> <span style="font-weight: bold;">number</span> A (<span style="font-weight: bold; font-style: italic;">s</span> : seq A) : nat :=
  <span style="font-weight: bold; text-decoration: underline;">match</span> s <span style="font-weight: bold; text-decoration: underline;">with</span>
      cons _ tl =&gt; S (number tl)
    | nil =&gt; 0
  <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<p>
where the parameter <code>A</code> of the function <code>number</code> is automatically memorized by <code>COQ</code>
as hidden / implicit.
</p>

<p>
Elsewhere, memo that any sequence <code>[:: true; false; true]</code> may be commonly viewed as
some function <code>[:: 0 |-&gt; true; 1 |-&gt; false; 2 |-&gt; true]</code> which when given some
position <code>0</code> , <code>1</code> or <code>2</code> output the corresponding item <code>true</code> , <code>false</code> or <code>true</code> of
the sequence. Therefore oneself may input any sequence and input another function as
both arguments to some <span class="underline">composition</span> / <span class="underline">map</span> (polymorphic) function :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Fixpoint</span> <span style="font-weight: bold;">map</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) (<span style="font-weight: bold; font-style: italic;">B</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) (<span style="font-weight: bold; font-style: italic;">f</span> : A -&gt; B) (<span style="font-weight: bold; font-style: italic;">s</span> : seq A) : seq B :=
  <span style="font-weight: bold; text-decoration: underline;">if</span> s <span style="font-weight: bold; text-decoration: underline;">is</span> e :: tl 
  <span style="font-weight: bold; text-decoration: underline;">then</span> f e :: map f tl 
  <span style="font-weight: bold; text-decoration: underline;">else</span> nil.
</pre>
</div>

<p>
For example to negate each item of some boolean list or to increment each item of some
numbers list :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> map (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">i</span> : bool =&gt; ~~ i) [:: true; false; true].
<span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> map (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">i</span> : nat =&gt; i.+1) [:: 2; 1; 3].
<span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> [seq i.+1 | i &lt;- [:: 2; 1; 3]].
</pre>
</div>

<pre class="example">
= [:: false; true; false]
: seq bool

= [:: 3; 2; 4]
: seq nat

= [:: 3; 2; 4]
: seq nat
</pre>

<p>
where this more-advanced <span class="underline">notation which binds / holds some identifier / name</span>, was
used ( the identifier <code>i</code> is bound / held in the term <code>E</code> ) :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Notation</span> <span style="font-style: italic;">"[ 'seq' E | i &lt;- s ]"</span> := (map (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">i</span> =&gt; E) s).
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq">Reset map.
</pre>
</div>

<p>
In addition to the function <code>map</code> there are more <i>advanced-polymorphic</i> function which
only-touch sequences, as described in the file <code>seq.v</code>. For instance the <code>filter</code>
function and its notation <code>[seq i &lt;- s | p]</code> filters the sequence <code>s</code> keeping only the
values selected by the boolean test <code>p</code>, whenever the common parameter <code>A</code>
itself-as-data may be classified ( "canonical structures" ) &#x2026;
</p>

<p>
Elsewhere, memo that because <code>map</code> takes <i>some function as input</i> it is said to be
some <span class="underline">higher-order function</span>. Morever <code>map</code> may also be viewed as <i>outputing some
function</i> when <code>map</code> is only <span class="underline">partially applied / inputed</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> map (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">i</span> : bool =&gt; ~~ i) [:: true; false; true].
<span style="font-weight: bold;">Check</span> map (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">i</span> : bool =&gt; ~~ i) .
</pre>
</div>

<pre class="example">
[seq ~~ i | i &lt;- [:: true; false; true]]
     : seq bool
</pre>

<p>
Finally, oneself shall clarify the link of <code>bool</code> with <code>option</code>, and the link of <code>nat</code>
with <code>seq</code>. Primo, define the (non-polymorphic) <span class="underline">unit type / class</span> which has some
single constructor <code>tt</code> (and only one inhabitant) :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">unit</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span> :=  tt : unit.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq">Reset unit.
</pre>
</div>

<p>
Secondo, it is now clear that there is some correspondence of <code>bool</code> with <code>option
unit</code>, and that there is some correspondence of <code>nat</code> with <code>seq unit</code> &#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-org6b5c68a" class="outline-2">
<h2 id="org6b5c68a"><span class="section-number-2">4</span> Classification</h2>
<div class="outline-text-2" id="text-4">
<p>
Another review at this instance of recursive function defined over the numbers
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> nat_rect.
</pre>
</div>

<pre class="example">
nat_rect = 
fun (P : nat -&gt; Type) (f : P 0) (f0 : forall n : nat, P n -&gt; P n.+1) =&gt;
fix F (n : nat) : P n :=
  match n as n0 return (P n0) with
  | 0 =&gt; f
  | n0.+1 =&gt; f0 n0 (F n0)
  end
     : forall P : nat -&gt; Type,
       P 0 -&gt; (forall n : nat, P n -&gt; P n.+1) -&gt; forall n : nat, P n

Argument scopes are [function_scope _ function_scope nat_scope]
</pre>

<p>
shows that these given alternate constructions <code>O | S (n : nat)</code> of the class <code>nat</code>
<span class="underline">computationally or logically fulfill</span> / <span class="underline">support</span> this class, which is that it is
sufficient to focus / touch on these (recursively) constructored data when holding
this class, which is that any (random) data in the class may be such (recursively)
<span class="underline">destructed</span> / <span class="underline">eliminated</span> / <span class="underline">matched</span> / <span class="underline">filtered</span>. This is described by this
(grammatical) <span class="underline">destructor / match function</span>
</p>

<pre class="example">
match .. as .. return .. with .. =&gt; .. | .. =&gt; .. end
</pre>

<p>
and maybe, for enabling recursion / reference to self (here <code>F</code> may textually mention
<code>F</code> in its definition), some surrounding <code>fix F n</code> keytext instead of the <code>fun n</code>
keytext :
</p>

<pre class="example">
fix .. := ..
</pre>

<p>
Now while any <code>bool</code> or <code>nat</code> or <code>list nat</code> or <code>list A</code> is some single isolated class
/ type, this above expression <code>(P : nat -&gt; Type)</code> says that <code>P</code> is some
<span class="underline">classification</span> or some <span class="underline">family / collection of classes</span> or some <span class="underline">dependent class</span> or
some <span class="underline">predicate</span>; such that <code>P 0 : Type</code> is some class and <code>P 1 : Type</code> is another
class and <code>P 2 : Type</code> is also some class &#x2026; And oneself is attempting to define some
(recursive) function <code>nat_rect</code> from the class <code>nat</code> to the classification <code>P</code>, such
that the input <code>n</code> from <code>nat</code> <i>affect both</i> the <span class="underline">precise-classification</span> of the output
( here <code>P n</code> ) and the <span class="underline">value</span> of the output ( here <code>f</code> when <code>n</code> is <code>O</code> , or <code>f0 n0 (F
n0)</code> when <code>n</code> is <code>S n0</code> ).
</p>

<p>
Saying how the input affect the <i>precise-classification</i> of the output is done by the
keytext
</p>

<pre class="example">
as .. return ..
</pre>

<p>
Saying how the input affect the <i>value</i> of the output is done by the keytext
</p>

<pre class="example">
with .. =&gt; .. | .. =&gt; .. end
</pre>

<p>
.. and certainly each filtering of the input for deciding which alternative branching
will, as usual, instantiate / <span class="underline">refine</span> the proposed output value but also instantiate
/ refine the expected classification / type of the output.
</p>
</div>

<div id="outline-container-org545010e" class="outline-3">
<h3 id="org545010e"><span class="section-number-3">4.1</span> List classification</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Another example of some classification similar as <code>(P : nat -&gt; Type)</code> is the
<span class="underline">indexed lists</span>, which futher classifies lists by some <span class="underline">index / argument</span>, whose sense
here is similar as « size (number form) of the list » :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">ilist</span> : nat -&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span> := 
    inil : ilist 0 
  | icons : nat -&gt; <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">m</span> : nat, ilist m -&gt; ilist (S m).
</pre>
</div>

<pre class="example">
ilist is defined
ilist_rect is defined
ilist_ind is defined
ilist_rec is defined
</pre>

<p>
Attempt now to define some (recursive) function from <code>nat</code> to <code>ilist</code> , which input
some number <code>m</code> and output something precisely-classified by <code>ilist m</code> and whose value
has all its items being <code>7</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">only7</span> :=
  <span style="font-weight: bold; text-decoration: underline;">fix</span> only7 (<span style="font-weight: bold; font-style: italic;">m</span> : nat) : (ilist m) :=
    <span style="font-weight: bold; text-decoration: underline;">match</span> m <span style="font-weight: bold; text-decoration: underline;">as</span> m' <span style="font-weight: bold; text-decoration: underline;">return</span> (ilist m') <span style="font-weight: bold; text-decoration: underline;">with</span>
      O =&gt; inil 
    | S m0 =&gt; icons 7 (only7 m0)
    <span style="font-weight: bold; text-decoration: underline;">end</span> .
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> only7 3.
</pre>
</div>

<pre class="example">
= icons 7 (icons 7 (icons 7 inil))
: ilist 3
</pre>

<p>
Another way of writing the same thing is :
</p>

<div class="org-src-container">
<pre class="src src-coq">Reset only7.
<span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">only7</span> :=
  nat_rect (ilist) (inil) (<span style="font-weight: bold; text-decoration: underline;">fun</span> (<span style="font-weight: bold; font-style: italic;">m0</span> : nat) (<span style="font-weight: bold; font-style: italic;">only7_m0</span> : ilist m0) =&gt; icons 7 only7_m0).
</pre>
</div>
</div>
</div>

<div id="outline-container-org6db58f1" class="outline-3">
<h3 id="org6db58f1"><span class="section-number-3">4.2</span> Equality classification</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Another example of some classification similar as <code>(P : nat -&gt; Type)</code> is the
<span class="underline">equality classification</span>, which classifies <span class="underline">(primitive or complex) deductions</span> /
<span class="underline">proofs</span> of "equality" to some given fixed (outer) parameter <code>x</code> ; this classification
is by whatelse (inner) arguments / indices this fixed parameter <code>x</code> is possibly
(by-computation-and-by-logical-deduction-)"equal" (eq) to :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">eq</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) (<span style="font-weight: bold; font-style: italic;">x</span> : A) : A -&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span> :=
  eqrefl : @eq A x x .
</pre>
</div>

<pre class="example">
eq is defined
eq_rect is defined
eq_ind is defined
eq_rec is defined
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> eqrefl.
</pre>
</div>

<pre class="example">
eqrefl : forall (A : Type) (x : A), eq x x

eqrefl is template universe polymorphic
Argument A is implicit
Argument scopes are [type_scope _]
Expands to: Constructor Top.eqrefl
</pre>

<p>
And the infix notation <code>x = a</code> is often used for saying <code>@eq A x a</code>, where the hidden
/ implicit parameter <code>A</code> will be inferred / guessed by the <code>COQ</code> computer.
</p>

<p>
From the meta (outer) angle of view, <code>eqrefl</code> is some primitive <span class="underline">deduction / proof
term / value</span> which says ( asserts / deduces / proves ) that the parameter <code>x</code> is "eq"
("equal") to any index-argument <code>y</code> which <span class="underline">by-computation-is</span> ( <span class="underline">by-convertibility-is</span>
) <code>x</code> ; and <code>eqrefl</code> is precisely-classified inside <code>@eq A x y</code> by any index-argument
<code>y</code> which by-computation-is <code>x</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> @eqrefl nat (3 + 2) : @eq nat (3 + 2) (S (S (1 + 2))).
</pre>
</div>

<pre class="example">
eqrefl (3 + 2) : eq (3 + 2) (1 + 2).+2
     : eq (3 + 2) (1 + 2).+2
</pre>

<p>
From the meta (outer) angle of view, the description of "eq" above may be read as :
</p>

<pre class="example">
Inductive eq (A : Type) (x : A) : A -&gt; Type :=
  eqrefl : forall ?y which by-computation-is x , @eq A x ?y .
</pre>

<p>
Now, deductions may be combinated in complex ways; which is that oneself may arrive at
<code>@eq A x y</code> by more-complex combinaisons ( <span class="underline">by-logical-deduction</span> ) beyond
precisely-one-primitive-deduction ( <span class="underline">by-computation</span> ) <code>eqrefl</code> . Therefore any
(random) data / inhabitant <code>lemma1 : @eq A x z</code> is named <span class="underline">logical-deduction</span>.
</p>

<p>
Here is one instance of combining deductions : how to input some deduction data from
<code>(@eq nat x a)</code> and output some deduction into <code>(@eq nat (S x) (S a))</code> which is
further-classified by the index-argument <code>(S a)</code> of the classification <code>(@eq nat (S
x))</code> . This uses the (grammatical) destructor / match function on "equality", which is
named <span class="underline">(congruent) rewriting</span> / <span class="underline">casting</span> / <span class="underline">transport</span>.  This may look silly :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span>
  (<span style="font-weight: bold; text-decoration: underline;">fun</span> (<span style="font-weight: bold; font-style: italic;">x</span> : nat) (<span style="font-weight: bold; font-style: italic;">a</span> : nat) (<span style="font-weight: bold; font-style: italic;">H</span> : @eq nat x a) =&gt;
     <span style="font-weight: bold; text-decoration: underline;">match</span> H <span style="font-weight: bold; text-decoration: underline;">as</span> H0 <span style="font-weight: bold; text-decoration: underline;">in</span> (@eq _ _ a0) <span style="font-weight: bold; text-decoration: underline;">return</span> (@eq nat (S x) (S a0)) <span style="font-weight: bold; text-decoration: underline;">with</span>
     | @eqrefl _ _ =&gt; @eqrefl nat (S x)
     <span style="font-weight: bold; text-decoration: underline;">end</span>)
     : <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">x a</span> : nat, @eq nat x a -&gt; @eq nat (S x) (S a) .
</pre>
</div>

<pre class="example">
(fun (x a : nat) (H : eq x a) =&gt;
 match H in (eq _ a0) return (eq x.+1 a0.+1) with
 | @eqrefl _ _ =&gt; eqrefl x.+1
 end)
  : (forall x a : nat, eq x a -&gt; eq x.+1 a.+1)
     : forall x a : nat, eq x a -&gt; eq x.+1 a.+1
</pre>

<p>
Saying how the input affect the precise-classification of the output is done by the
keytext
</p>

<pre class="example">
as .. in .. return ..
</pre>

<p>
which has some extra <code>in ..</code> keytext now because the input data is taken from some
<i>classification</i> <code>(@eq nat (S x))</code> instead of from only some class such as the earlier
<code>bool</code> or <code>nat</code> examples.
</p>

<p>
This full grammar <code>as .. in .. return ..</code> is because « <span class="underline">the input</span> » <code>H</code> <span class="underline">is both the
input value</span> (the <code>H0</code> in the <code>as H0</code> keytext) <span class="underline">and the input precise-classification</span>
(the argument <code>a0</code> in the <code>in @eq _ _ a0</code> keytext); and both the input value and input
precise-classification do affect the expected output precise-classification (here
<code>return (@eq nat (S x) (S a0))</code> , where <code>H0</code> is absent here only-by-chance). However
the value of the output in each alternative branch has only access to the destructed
value of the input and <i>no direct-access</i> to the precise-classification of the input.
</p>

<p>
Another example which uses this full grammar <code>as .. in .. return ..</code> is this <code>more</code>
function, which increments all the items in some indexed list and creates one more
item :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">more</span> :=
  (<span style="font-weight: bold; text-decoration: underline;">fix</span> more (<span style="font-weight: bold; font-style: italic;">m</span> : nat) (<span style="font-weight: bold; font-style: italic;">l</span> : ilist m) {<span style="font-weight: bold; text-decoration: underline;">struct</span> l} : ilist (S m) :=
     <span style="font-weight: bold; text-decoration: underline;">match</span> l <span style="font-weight: bold; text-decoration: underline;">as</span> l0 <span style="font-weight: bold; text-decoration: underline;">in</span> ilist m0 <span style="font-weight: bold; text-decoration: underline;">return</span> ilist (S m0) <span style="font-weight: bold; text-decoration: underline;">with</span>
       inil =&gt; icons 0 inil
     | icons j m_tl tl =&gt; icons (S j) (more m_tl tl)
     <span style="font-weight: bold; text-decoration: underline;">end</span>).
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> @more 3 (icons 6 (icons 7 (icons 5 inil))).
</pre>
</div>

<pre class="example">
= icons 7 (icons 8 (icons 6 (icons 0 inil)))
: ilist 4
</pre>

<p>
Another example which uses nothing of this full grammar <code>as .. in .. return ..</code>
(because the ouput classification <code>nat</code> does not lack it) is this <code>inumber</code> ( "isize"
) function, which computes the <i>real size</i> (number of items, number form) of some
indexed list.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">inumber</span> :=
  (<span style="font-weight: bold; text-decoration: underline;">fix</span> inumber (<span style="font-weight: bold; font-style: italic;">m</span> : nat) (<span style="font-weight: bold; font-style: italic;">l</span> : ilist m) {<span style="font-weight: bold; text-decoration: underline;">struct</span> l} : nat :=
     <span style="font-weight: bold; text-decoration: underline;">match</span> l <span style="font-weight: bold; text-decoration: underline;">with</span>
       inil =&gt; 0
     | icons j m_tl tl =&gt; S (inumber m_tl tl)
     <span style="font-weight: bold; text-decoration: underline;">end</span>).
</pre>
</div>

<p>
Finally one may (recursively) <span class="underline">program some deduction</span> <code>lemma1</code> which deduces that the
(sense of the) index-argument (the precise-classification) of some indexed list is
indeed "equal" (eq) to the real size (number of items) of this indexed list.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">lemma1</span> :=
  <span style="font-weight: bold; text-decoration: underline;">fix</span> lemma1 (<span style="font-weight: bold; font-style: italic;">m</span> : nat) (<span style="font-weight: bold; font-style: italic;">l</span> : ilist m) {<span style="font-weight: bold; text-decoration: underline;">struct</span> l} : @eq nat m (inumber l) :=
    <span style="font-weight: bold; text-decoration: underline;">match</span> l <span style="font-weight: bold; text-decoration: underline;">as</span> l0 <span style="font-weight: bold; text-decoration: underline;">in</span> ilist m0 <span style="font-weight: bold; text-decoration: underline;">return</span> @eq nat m0 (inumber l0) <span style="font-weight: bold; text-decoration: underline;">with</span>

      inil =&gt;
        <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">expected (goal) output precise-classification :</span>
<span style="font-weight: bold; font-style: italic;">        @eq nat 0 (inumber (inil)) , which computationally-is</span>
<span style="font-weight: bold; font-style: italic;">        @eq nat 0 O  *</span><span style="font-weight: bold; font-style: italic;">*)</span>
        @eqrefl nat 0

    | icons j m_tl tl =&gt;
        <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">expected (goal) output precise-classification :</span>
<span style="font-weight: bold; font-style: italic;">        @eq nat (S m_tl) (inumber (icons j m_tl tl)) , which computationally-is</span>
<span style="font-weight: bold; font-style: italic;">        @eq nat (S m_tl) (S (inumber tl)) ;</span>

<span style="font-weight: bold; font-style: italic;">        now by recursion, the deduction (lemma1 m_tl tl) of classification</span>
<span style="font-weight: bold; font-style: italic;">        @eq nat (m_tl) ((inumber tl)),</span>
<span style="font-weight: bold; font-style: italic;">        is present to do some rewrite / cast / transport  *</span><span style="font-weight: bold; font-style: italic;">*)</span>
        <span style="font-weight: bold; text-decoration: underline;">match</span> (lemma1 m_tl tl) <span style="font-weight: bold; text-decoration: underline;">as</span> H0 <span style="font-weight: bold; text-decoration: underline;">in</span> @eq _ _ a0 <span style="font-weight: bold; text-decoration: underline;">return</span> @eq nat (S m_tl) (S a0) <span style="font-weight: bold; text-decoration: underline;">with</span>
          @eqrefl _ _ =&gt;
            <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">expected (goal) output precise-classification :</span>
<span style="font-weight: bold; font-style: italic;">            @eq nat (S m_tl) (S m_tl)  *</span><span style="font-weight: bold; font-style: italic;">*)</span>
            @eqrefl nat (S m_tl)
        <span style="font-weight: bold; text-decoration: underline;">end</span>

    <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<p>
Such programming of deduction may also be done using <span class="underline">script / tactical commands</span>
which prevent programmer fatigue and sometimes automate the writing of very long
deductions / proof terms / values. Such script is started by the <code>Lemma</code> command, then
the <code>COQ</code> computer prints the expected (goal) classification of the ouput deduction :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">lemma2</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span> (<span style="font-weight: bold; font-style: italic;">m</span> : nat) (<span style="font-weight: bold; font-style: italic;">l</span> : ilist m), @eq nat m (inumber l).
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall (m : nat) (l : ilist m), eq m (inumber l)
</pre>

<p>
Early oneself may decide-and-rest the names of the quantified variables or
assumptions, by using the <code>intros</code> command (or the almost-same <code>move =&gt; ..</code> command) :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move =&gt; m l .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">intros</span> m l.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m : nat
  l : ilist m
  ============================
  eq m (inumber l)
</pre>

<p>
Now the <code>fix lemma2 m l {struct l} := match l .. with .. =&gt; .. | .. =&gt; .. end</code> keytext
corresponds to the <code>induction</code> command (or the almost-same <code>elim</code> command), then the
<code>COQ</code> computer prints, for each filtering of the input, the expected (goal)
precise-classification of the output deduction; the <code>inil =&gt; ..</code> alternative branch
shall be solved first :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">elim : l =&gt; [ | j m_tl tl lemma2_m_tl_tl ] .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">induction</span> l <span style="font-weight: bold; text-decoration: underline;">as</span> [ | j m_tl tl lemma2_m_tl_tl ]  .
</pre>
</div>

<pre class="example">
2 subgoals
  
  ============================
  eq 0 (inumber inil)

subgoal 2 is:
 eq m_tl.+1 (inumber (icons j tl))
</pre>

<p>
Now the (hidden, implicit, automatic) computation by the <code>COQ</code> computer in this branch
may be made explicit by using the <code>simpl</code> command (or the almost-same <code>.. =&gt; /= ..</code>
command).
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move =&gt; /= .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">simpl</span>.
</pre>
</div>

<pre class="example">
2 subgoals
  
  ============================
  eq 0 0

subgoal 2 is:
 eq m_tl.+1 (inumber (icons j tl))
</pre>

<p>
Finally for this branch, the basic (constructor) deduction <code>@eqrefl nat 0</code> is <i>exactly
/ precisely</i> what will solve this goal and print the next goal, therefore oneself may
use the <code>exact</code> command :
</p>

<div class="org-src-container">
<pre class="src src-coq">exact (@eqrefl nat 0).
</pre>
</div>

<pre class="example">
1 subgoal
  
  j, m_tl : nat
  tl : ilist m_tl
  lemma2_m_tl_tl : eq m_tl (inumber tl)
  ============================
  eq m_tl.+1 (inumber (icons j tl))
</pre>

<p>
Again the (hidden, implicit, automatic) computation by the <code>COQ</code> computer in this
second branch <code>icons j m_tl tl =&gt; ..</code> may be made explicit by using the <code>simpl</code>
command.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move =&gt; /= .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">simpl</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  j, m_tl : nat
  tl : ilist m_tl
  lemma2_m_tl_tl : eq m_tl (inumber tl)
  ============================
  eq m_tl.+1 (inumber tl).+1
</pre>

<p>
Now the rewriting / cast / transport is done in 3 progress; the first progress, which
is the <code>revert</code> command (or the almost-same <code>move : ..</code> command) followed by the
<code>generalize</code> command (or the almost-same <code>move : ..</code> command), corresponds to the
keytext <code>(lemma2_m_tl_tl) as H0 in @eq _ _ a0 return @eq nat (S m_tl) (S a0)</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move : lemma2_m_tl_tl .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">revert</span> lemma2_m_tl_tl.
</pre>
</div>

<pre class="example">
1 subgoal
  
  j, m_tl : nat
  tl : ilist m_tl
  ============================
  eq m_tl (inumber tl) -&gt; eq m_tl.+1 (inumber tl).+1
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move : (inumber tl) .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">generalize</span> (inumber tl) <span style="font-weight: bold; text-decoration: underline;">as</span> a0.
</pre>
</div>

<pre class="example">
1 subgoal
  
  j, m_tl : nat
  tl : ilist m_tl
  ============================
  forall a0 : nat, eq m_tl a0 -&gt; eq m_tl.+1 a0.+1
</pre>

<p>
These two related steps of the same progress may be combined by the <code>.. ; ..</code> command
(or may be combined on the same text line of the <code>.. : ..</code> command) :
</p>

<div class="org-src-container">
<pre class="src src-coq">Undo 2.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move : (inumber tl) lemma2_m_tl_tl .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">revert</span> lemma2_m_tl_tl ; <span style="text-decoration: underline;">generalize</span> (inumber tl) <span style="font-weight: bold; text-decoration: underline;">as</span> a0 .
</pre>
</div>

<p>
And the second progress which is the <code>destruct</code> command (or the almost-same <code>case</code>
command), corresponds to the keytext <code>match .. with @eqrefl _ _ =&gt; .. end</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">move =&gt; a0 ; case .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">destruct</span> 1.
</pre>
</div>

<pre class="example">
1 subgoal
  
  j, m_tl : nat
  tl : ilist m_tl
  ============================
  eq m_tl.+1 m_tl.+1
</pre>

<p>
Memo that if this hand-crafted <code>eq</code> were the initial real <code>COQ</code> <code>eq</code>, then these 2
progresses (<code>revert</code> followed by <code>generalize</code> followed by <code>destruct</code>) may be combined
into some single command <code>rewrite &lt;- lemma2_m_tl_tl .</code> , where the sense of the arrow
<code>&lt;-</code> is <i>right-to-left rewriting</i>.
</p>

<p>
Finally for this branch, the basic (constructor) deduction <code>@eqrefl nat 0</code> is <i>exactly
/ precisely</i> what will make the third progress and solve this goal. Alternatively of
using the <code>exact (@eq_refl nat (S m_tl)).</code> command, oneself may use the <code>apply</code>
command, which allow to progress slowly partially, eventually producing some rest of
goals (here none) :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">apply : eqrefl .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">apply</span> eqrefl.
</pre>
</div>

<pre class="example">
No more subgoals.
</pre>

<p>
And these next commands tell the <code>COQ</code> computer to memorize the deduction (as
<code>lemma2</code>), and then to print its deduction term / value for comparison with the
manually-programmed deduction term memorized in <code>lemma1</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">Qed .*</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="font-weight: bold;">Defined</span>.
</pre>
</div>

<pre class="example">
(intros m l).
(induction l as [| j m_tl tl lemma2_m_tl_tl]).
 (simpl).
 exact (@eqrefl nat 0).

 (simpl).
 (revert lemma2_m_tl_tl; generalize (inumber tl) as a0).
 (destruct 1).
 (apply eqrefl).

Defined.
lemma2 is defined
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> lemma2.
</pre>
</div>

<pre class="example">
lemma2 = 
fun m : nat =&gt;
[eta ilist_ind (eqrefl 0)
       (fun (j m_tl : nat) (tl : ilist m_tl) =&gt;
        [eta (fun (a0 : nat) (lemma2_m_tl_tl0 : eq m_tl a0) =&gt;
              match lemma2_m_tl_tl0 in (eq _ y) return (eq m_tl.+1 y.+1) with
              | @eqrefl _ _ =&gt; eqrefl m_tl.+1
              end) (inumber tl)]) (n:=m)]
     : forall (m : nat) (l : ilist m), eq m (inumber l)

Argument m is implicit
Argument scopes are [nat_scope _]
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">unfold</span> lemma2, ilist_ind, ilist_rect <span style="font-weight: bold; text-decoration: underline;">in</span> lemma2.
</pre>
</div>

<pre class="example">
= fun (m : nat) (l : ilist m) =&gt;
  (fix F (n : nat) (i : ilist n) {struct i} : 
   eq n (inumber i) :=
     match i as i0 in (ilist n0) return (eq n0 (inumber i0)) with
     | inil =&gt; eqrefl 0
     | @icons _ m0 i0 =&gt;
         match F m0 i0 in (eq _ y) return (eq m0.+1 y.+1) with
         | @eqrefl _ _ =&gt; eqrefl m0.+1
         end
     end) m l
: forall (m : nat) (l : ilist m), eq m (inumber l)
</pre>
</div>
</div>
</div>

<div id="outline-container-org54615d6" class="outline-2">
<h2 id="org54615d6"><span class="section-number-2">5</span> Deduction : functions</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-org84df6f1" class="outline-3">
<h3 id="org84df6f1"><span class="section-number-3">5.1</span> Goal as nested-stack</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Primo, the angle of view is that any class / goal such as <code>((nat -&gt; nat) -&gt; nat -&gt;
nat)</code> is similar as some nested stack.
</p>

<p>
Secondo, memo that there is some flexibility when writing some type / goal, as in :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Goal</span> <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">xy</span> : prod nat nat, prime (fst (<span style="font-weight: bold; font-style: italic;">xy</span> : (nat * nat)%type)) -&gt;
                 odd xy.2 = true -&gt; leq 2 ((snd xy) + xy.1) .
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall xy : nat * nat,
  prime (xy : nat * nat).1 -&gt; odd xy.2 = true -&gt; 1 &lt; xy.2 + xy.1
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Unset Printing Notations</span>.
<span style="font-weight: bold;">Show</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall (xy : prod nat nat) (_ : prime (fst (xy : prod nat nat)))
    (_ : Logic.eq (odd (snd xy)) true),
  leq (S (S O)) (addn (snd xy) (fst xy))
</pre>

<p>
Here the <span class="underline">pairing type former</span> <code>prod</code> ( described below ) is subtituted by its infix
notation <code>*</code> , which may be precised by some more <span class="underline">annotation / scope</span> <code>( .. )%type</code>
when it is necessary to distinguish it from the infix notation <code>*</code> of <code>multn</code> , which
may be precised by some other annotation / scope <code>( .. )%nat</code> . Also <code>.1</code> and <code>.2</code> are
postfix notations for correspondingly the functions <code>fst</code> and <code>snd</code> .
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Locate</span> <span style="font-style: italic;">"*"</span>.
</pre>
</div>

<pre class="example">
Notation            Scope     
"m * n" := Nat.mul m n         : coq_nat_scope
                      
"m * n" := muln_rec m n        : nat_rec_scope
                      
"m * n" := muln m n  : nat_scope
                      (default interpretation)
"x * y" := prod x y  : type_scope
</pre>

<p>
Elsewhere one may write <code>leq 2 ((snd xy) + xy.1)</code> , instead of <code>leq 2 ((snd xy) +
xy.1) = true</code> as it was done for <code>odd xy.2 = true</code> . Similarly one may write <code>prime
xy.1</code> , instead of <code>prime xy.1 = true</code> . This notational process is named <code>coercive
notation</code> ( or <code>automatic declassification</code> ) and is based from this function :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Eval</span> <span style="text-decoration: underline;">compute</span> <span style="font-weight: bold; text-decoration: underline;">in</span> (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">b</span> : bool =&gt; (<span style="font-weight: bold; font-style: italic;">is_true b</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>)).
</pre>
</div>

<pre class="example">
= fun b : bool =&gt; Logic.eq b true
: forall _ : bool, Type
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Set Printing Coercions</span>.
<span style="font-weight: bold;">Show</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall (xy : prod nat nat) (_ : is_true (prime (fst (xy : prod nat nat))))
    (_ : Logic.eq (odd (snd xy)) true),
  is_true (leq (S (S O)) (addn (snd xy) (fst xy)))
</pre>
</div>
</div>

<div id="outline-container-orgfd4ab6f" class="outline-3">
<h3 id="orgfd4ab6f"><span class="section-number-3">5.2</span> Intro from, apply in, specialize of, substitution by - the nested-stack</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The postfix <code>=&gt; ...</code> grammar may be used as post-processing phase of any proof
command, and it does some sequence of actions on the now-present <span class="underline">top / first
assumption or quantified variable</span> in the goal.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Goal</span> <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">xy</span> : nat * nat, prime xy.1 -&gt; odd xy.2 -&gt; 2 &lt; xy.2 + xy.1 .
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall xy : nat * nat, prime xy.1 -&gt; odd xy.2 -&gt; 2 &lt; xy.2 + xy.1
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> =&gt; xy .
</pre>
</div>

<pre class="example">
1 subgoal
  
  xy : nat * nat
  ============================
  prime xy.1 -&gt; odd xy.2 -&gt; 2 &lt; xy.2 + xy.1
</pre>

<div class="org-src-container">
<pre class="src src-coq">Undo.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> =&gt; xy =&gt; pr_x odd_y .
</pre>
</div>

<pre class="example">
1 subgoal
  
  xy : nat * nat
  pr_x : prime xy.1
  odd_y : odd xy.2
  ============================
  2 &lt; xy.2 + xy.1
</pre>

<p>
where the <code class="src src-coq">move.</code> command alone without post-processing does
nothing (almost, as in reality it performs <i>head normal form computation</i> such to
expose any prefix <code>forall</code> classifying inference / quantification). And the postfix
<code>=&gt; ..</code> grammar introduces the top assumption or variable into the <span class="underline">(outer) context</span>.
</p>

<p>
Now, en passant, oneself may want to decompose <code>xy</code> into its first and second
component. Instead of the long text <code>move=&gt; xy; destruct xy as [x y]</code> , oneself may
use this shorter grammar <code>[]</code> for the introduction filter to perform such action.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span>=&gt; [x y] pr_x odd_y.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  pr_x : prime (x, y).1
  odd_y : odd (x, y).2
  ============================
  2 &lt; (x, y).2 + (x, y).1
</pre>

<p>
Oneself may place the <code>/=</code> option to command <code>COQ</code> to <span class="underline">partially-compute (simplify)</span>
the terms on the nested-stack before introducing them into the (outer) context. This
is the same as the <code class="src src-coq">simpl.</code> command.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span>=&gt; [x y] /= pr_x odd_y.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  pr_x : prime x
  odd_y : odd y
  ============================
  2 &lt; y + x
</pre>

<p>
Oneself may also <span class="underline">apply / instantiate some lemma by some assumption</span> ( or confusingly,
<i>view some assumption</i> ). For example the lemma <code>prime_gt1 : forall p : nat, prime p
-&gt; 1 &lt; p</code> , where the variable argument <code>p</code> is implicit, may be be applied onto
(instantiated by) the top assumption <code>(prime x)</code> such to transform the top assumption
as now <code>(1 &lt; x)</code>, by placing the <code>/prime_gt1</code> option ( <i>view</i> ) on the <code>=&gt; ...</code>
grammar line. This is the same as the common <code>apply .. in ..</code> command &#x2026;
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span>=&gt; [x y] /= /prime_gt1-x_gt1 odd_y.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  odd_y : odd y
  ============================
  2 &lt; y + x
</pre>

<p>
where the <code>-</code> text, which visually link the function and name assigned to its output,
has no effect and may be erased.
</p>

<p>
In reality, the class / type of the applied lemma <code>lemma1 : A -&gt; B</code> on the top
assumption <code>A</code> of the <span class="underline">inner context</span> not lack to be of the precise form <code>A -&gt; B</code> ;
for example this lemma may be of type <code>lemma1 : B &lt;-&gt; A</code> and therefore the <code>COQ</code>
computer shall automatically-transform this lemma from <code>(lemma1)</code> to <code>(@iffRL _ _
(lemma1)) : A -&gt; B</code> before actually applying it onto the top assumption <code>A</code> of the
inner context. This process is named <span class="underline">enabling the query of the view / transformation
hints</span>; and some of these hints are already pre-memorized in the <code>ssreflect.v</code> file
after some <code>Require Import mathcomp.ssreflect.ssreflect.</code> command.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> @iffRL : <span style="font-weight: bold; text-decoration: underline;">forall</span> P Q (<span style="font-weight: bold; font-style: italic;">eqPQ</span> : P &lt;-&gt; Q), Q -&gt; P. 
<span style="font-weight: bold;">Hint View for</span> <span style="text-decoration: underline;">move</span>/ iffRL|2 <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">this 2 refer to the 2 _ prefixing @iffRL _ _ above*</span><span style="font-weight: bold; font-style: italic;">*)</span>.
</pre>
</div>

<pre class="example">
iffRL : (forall P Q : Prop, P &lt;-&gt; Q -&gt; Q -&gt; P)
     : forall P Q : Prop, P &lt;-&gt; Q -&gt; Q -&gt; P
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span>=&gt; [x y] /= /prime_gt1'-[x_gt1 x_pr] odd_y.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  x_pr : prime x
  odd_y : odd y
  ============================
  2 &lt; y + x
</pre>


<p>
Oneself may also examine <code>y</code> : it shall not be <code>0</code> , since this would make the
assumption <code>odd y</code> compute to <code>false</code> which is some easy contradiction which
immediately solves this branch of the goal (in other words : the zero case / branch
where <code>y</code> is <code>0</code> is <span class="underline">immediately solved</span> because of the presence of some easy
contradiction in the assumptions). The <code>//</code> option of the <code>=&gt; ...</code> grammar commands
<code>COQ</code> to attempt to <i>immediately solve</i> the goal. This is the same as the <code>done.</code> or
<code>by [].</code> composite-commands &#x2026;
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span>=&gt; [ x [ // | y ] ] /= /prime_gt1-x_gt1.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  ============================
  ~~ odd y -&gt; 2 &lt; y.+1 + x
</pre>

<p>
where the <code>[ .. | .. ]</code> grammar here is same as <code>destruct y as [ | y ]</code> which
generates two branches / cases for the two constructors of the data class <code>nat</code> . Memo
that the same name ( here <code>y</code> ) may be masking / reused for filter-held / filter-bound
filter-variables, in some comparable way as for funtional-held function-variable.
</p>

<p>
Now, oneself knows that the assumption saying <code>y</code> is even is not lacked to solve,
therefore oneself may <span class="underline">clear</span> this assumption by one of two ways : by first
introducing it using some common name then clearing it using the <code>{ .. }</code> option or by
introducing it using the <code>_</code> dummy name. Memo that the <code>by</code> <span class="underline">solving / closing
command</span> (and its introduction-filter synonym <code>.. =&gt; //</code> command) attempts to
immediately-solve any resting goal (here none) <i>orelse fails</i>, and is some <span class="underline">visual
textual marker</span> to communicate that the now-present goal is being <i>fully resolved</i>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span>=&gt; [x [//|y]] /= /prime_gt1-x_gt1 odd_y {odd_y}.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq">by <span style="text-decoration: underline;">move</span>=&gt; [ x [ // | y ] ] /= /prime_gt1-x_gt1 _ ; <span style="text-decoration: underline;">apply</span> (ltn_addl _ x_gt1).
</pre>
</div>

<pre class="example">
No more subgoals.
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> ltn_addl.
</pre>
</div>

<pre class="example">
ltn_addl : forall m n p : nat, m &lt; n -&gt; m &lt; p + n

Arguments m, n are implicit
Argument scopes are [nat_scope nat_scope nat_scope _]
ltn_addl is opaque
Expands to: Constant mathcomp.ssreflect.ssrnat.ltn_addl
</pre>

<p>
Dually of <i>apply / instantiate some lemma by some assumption</i>, oneself may also
<span class="underline">specialize/instantiate some assumption by some lemma</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Goal</span> (<span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">n</span>, n * 2 = n + n) -&gt; 6 = 3 + 3.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  (forall n : nat, n * 2 = n + n) -&gt; 6 = 3 + 3
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> =&gt; /(_ 3).
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  3 * 2 = 3 + 3 -&gt; 6 = 3 + 3
</pre>

<p>
This is almost same as applying / instantiating some other lemma <code>special1arg</code> by this
same assumption.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> =&gt; /(special1arg 3).
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  3 * 2 = 3 + 3 -&gt; 6 = 3 + 3
</pre>

<p>
Moreover, when the top stack item is some equation, oneself may <span class="underline">substitute-rewrite</span>
by this equation <span class="underline">then clear this equation</span>. The options <code>&lt;-</code> and <code>-&gt;</code> for the <code>.. =&gt;
...</code> grammar correspond to right-to-left and left-to-right substitutions. This is the
same as the common <code>rewrite</code> command, but now the equation is <i>cleared</i> from the
assumptions or outer context.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> =&gt; &lt;- .
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  6 = 3 * 2
</pre>

<p>
Finally, memo that the apply-in option ( <code>/lemma1</code> ) and specialize option ( <code>/(_
input1)</code> ) of the <code>move =&gt; ..</code> command may occur affixed to the <code>move/</code> keytext :
</p>

<div class="org-src-container">
<pre class="src src-coq">Undo 2.
<span style="text-decoration: underline;">move</span>/(special1arg 3).
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  (forall n : nat, n * 2 = n + n) -&gt; 6 = 3 + 3

1 subgoal
  
  ============================
  3 * 2 = 3 + 3 -&gt; 6 = 3 + 3
</pre>

<div class="org-src-container">
<pre class="src src-coq">Undo 1.
<span style="text-decoration: underline;">move</span>/(_ 3).
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  (forall n : nat, n * 2 = n + n) -&gt; 6 = 3 + 3

1 subgoal
  
  ============================
  3 * 2 = 3 + 3 -&gt; 6 = 3 + 3
</pre>

<p>
And memo for later that the command <code>case/lemma1</code> or <code>case/(_ input1)</code>
correspondingly-is short for the command <code>move/lemma1; case.</code> or <code>move/(_ input1);
case.</code> .
</p>
</div>
</div>

<div id="outline-container-org3949414" class="outline-3">
<h3 id="org3949414"><span class="section-number-3">5.3</span> Revert to, generalize in, unification of - the nested-stack</h3>
<div class="outline-text-3" id="text-5-3">
<p>
The postfix <code>.. : ..</code> grammar may be used as pre-processing phase of many proof
commands such as <code>move</code>, <code>case</code>, <code>elim</code> (and <code>apply</code> &#x2026;), and it essentially push
assumptions onto the goal nested-stack from somewhere else &#x2026;
</p>
</div>

<div id="outline-container-org5f28321" class="outline-4">
<h4 id="org5f28321"><span class="section-number-4">5.3.1</span> revert</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Oneself may want to de-structure <code>y</code> at this present-time, but oneself lacks to
pre-process the goal :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">goal1</span> (<span style="font-weight: bold; font-style: italic;">x y</span> : nat) (<span style="font-weight: bold; font-style: italic;">x_gt1</span> : 1 &lt; x) (<span style="font-weight: bold; font-style: italic;">odd_y</span> : odd y) : 2 &lt; y + x .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  odd_y : odd y
  ============================
  2 &lt; y + x
</pre>

<div class="org-src-container">
<pre class="src src-coq">Fail <span style="text-decoration: underline;">move</span> : y .
<span style="text-decoration: underline;">move</span> : y odd_y .
</pre>
</div>

<pre class="example">
The command has indeed failed with message:
Ltac call to "move (ssrmovearg) (ssrclauses)" failed.
Error: y is used in hypothesis odd_y.
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  odd_y : odd y
  ============================
  2 &lt; y + x
</pre>

<p>
Here the assumptions are pushed onto the goal nested-stack <i>from the outer context</i>;
this process is named <span class="underline">reverting variables / hypothesis</span>.
</p>

<p>
Then one more line containing the <code>case.</code> command will make the lacked
progress. Alternatively oneself may combine the <code>.. : ..</code> pre-processing grammar with
the <code>case</code> (destruct) processing with the <code>.. =&gt; ..</code> post-processing grammar on one
single line of text.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">case</span> : y odd_y =&gt; [ | y' ].
</pre>
</div>

<pre class="example">
2 subgoals
  
  x : nat
  x_gt1 : 1 &lt; x
  ============================
  odd 0 -&gt; 2 &lt; 0 + x

subgoal 2 is:
 odd y'.+1 -&gt; 2 &lt; y'.+1 + x
</pre>

<p>
which is same as commanding <code>move : y odd_y ; case =&gt; [ | y' ].</code> , where
exceptionally-for-case the <code>case =&gt; [ .. | .. ]</code> grammar with the bracketing <code>[ .. |
.. ]</code> immediately after the arrow <code>=&gt;</code> signify <i>branching</i> instead of (one more)
<i>destruction</i> &#x2026; When oneself really wants some additional <i>destruction</i>, one shall
write <code>case =&gt; - [ .. | .. ]</code> where the <code>-</code> keytext has no other effect.
</p>

<div class="org-src-container">
<pre class="src src-coq">Admitted.
</pre>
</div>

<pre class="example">
goal1 is declared
</pre>
</div>
</div>

<div id="outline-container-org4969822" class="outline-4">
<h4 id="org4969822"><span class="section-number-4">5.3.2</span> generalize, unification-generalize</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
Such above goal may sometimes occur in less-practical form :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">goal2</span> (<span style="font-weight: bold; font-style: italic;">x y1 y2</span> : nat) (<span style="font-weight: bold; font-style: italic;">x_gt1</span> : 1 &lt; x)
   (<span style="font-weight: bold; font-style: italic;">odd_y1y2</span> : odd (y1 - y2)) : 2 &lt; (y1 - y2) + x .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  2 &lt; y1 - y2 + x
</pre>

<p>
and therefore the term <code>(y1 - y2)</code> may be generalized such that oneself is back to the
more-practical form above and oneself may continue the same deduction :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : (y1 - y2) odd_y1y2 .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  ============================
  forall subn : nat, odd subn -&gt; 2 &lt; subn + x
</pre>

<p>
Alternatively, oneself may save / memorize this rest of the same deduction as some new
lemma <code>goal1</code> (this was done above), then immediately <code>apply</code> this saved lemma at the
start of this new deduction instead of manually-generalizing. This senses that the
<code>apply</code> command is some <span class="underline">unification-generalize</span> command.
</p>

<div class="org-src-container">
<pre class="src src-coq">Undo.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  2 &lt; y1 - y2 + x
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">apply</span> (goal1) .
</pre>
</div>

<pre class="example">
2 subgoals
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  1 &lt; x

subgoal 2 is:
 odd (y1 - y2)
</pre>

<p>
Yet another re-wording of this instantiation / application of lemma <code>goal1</code> is as
follows :
</p>
<ul class="org-ul">
<li>primo, oneself pushes the assumption which is the class / type of the lemma <code>goal1</code>
on top of the now-present inner-context goal, which is that oneself <i>generalizes the
now-present goal by any deduction of the class / type</i> of the lemma <code>goal1</code> ,
instead of directly-using the particular lemma <code>goal1</code> ,</li>
<li>secondo, in the inner-context, oneself apply this top assumption onto the conclusion.</li>
</ul>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : goal1 .
<span style="text-decoration: underline;">apply</span> .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  (forall x0 y : nat, 1 &lt; x0 -&gt; odd y -&gt; 2 &lt; y + x0) -&gt; 2 &lt; y1 - y2 + x

2 subgoals
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  1 &lt; x

subgoal 2 is:
 odd (y1 - y2)
</pre>

<p>
In reality, the following command will combine these two steps :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">apply</span> : goal1 .
</pre>
</div>

<pre class="example">
2 focused subgoals
(shelved: 2)
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  1 &lt; x

subgoal 2 is:
 odd (y1 - y2)
</pre>

<p>
and is precisely-same as these scripted composite-commands, where the <code>cmd1 || cmd2</code>
command says that <code>cmd1</code> succeed-and-progress else <code>cmd2</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">refine</span> ( @goal1 ) || ( <span style="text-decoration: underline;">refine</span> ( @goal1 _ ) ||
( <span style="text-decoration: underline;">refine</span> ( @goal1 _ _ ) || ( <span style="text-decoration: underline;">refine</span> ( @goal1 _ _ _ ) || 
<span style="text-decoration: underline;">refine</span> ( @goal1 _ _ _ _ ) ) ) ) <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">or more *</span><span style="font-weight: bold; font-style: italic;">*)</span> .
</pre>
</div>

<pre class="example">
2 subgoals
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  1 &lt; x

subgoal 2 is:
 odd (y1 - y2)
</pre>

<p>
Moreover, oneself may <span class="underline">enable the querying of the view / transformation hints
database</span> by affixing the lemma-to-be-applied to the <code>apply/</code> command :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">apply</span> / goal1 .
</pre>
</div>

<pre class="example">
2 focused subgoals
(shelved: 2)
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  1 &lt; x

subgoal 2 is:
 odd (y1 - y2)
</pre>

<p>
Finally, memo that the lemma may be some variable / hypothesis name in the outer
context instead of some save / memorized top / global lemma, in which case oneself
shall surround the variable / hypothesis name by parenthesis such to prevent such name
from being <i>cleared</i> from the outer context. For example :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : (x_gt1) .
</pre>
</div>

<pre class="example">
2 focused subgoals
(shelved: 1)
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  1 &lt; x -&gt; 1 &lt; x

subgoal 2 is:
 odd (y1 - y2)
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Abort</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b7c93a" class="outline-4">
<h4 id="org5b7c93a"><span class="section-number-4">5.3.3</span> revert-then-intro</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
Here is the process named <span class="underline">revert-then-intro</span> ( <span class="underline">contextualization of commands</span>
). For the same goal <code>goal2</code> as above,
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">goal2</span> (<span style="font-weight: bold; font-style: italic;">x y1 y2</span> : nat) (<span style="font-weight: bold; font-style: italic;">x_gt1</span> : 1 &lt; x)
   (<span style="font-weight: bold; font-style: italic;">odd_y1y2</span> : odd (y1 - y2)) : 2 &lt; (y1 - y2) + x .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  2 &lt; y1 - y2 + x
</pre>

<p>
when oneself wants to immediately re-introduce into the outer context all the changed
hypotheses (of the <i>outer context</i>) which are now assumptions (of the <i>inner context</i>)
of the generalized goal, oneself may do this command :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : (y1 - y2) =&gt; z <span style="font-weight: bold; text-decoration: underline;">in</span> odd_y1y2 * .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  z : nat
  odd_y1y2 : odd z
  ============================
  2 &lt; z + x
</pre>

<p>
instead of this less-clear command :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : (y1 - y2) odd_y1y2 =&gt; z odd_y1y1 .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  z : nat
  odd_y1y1 : odd z
  ============================
  2 &lt; z + x
</pre>

<p>
where the optional <code>*</code> keytext communicates that the <span class="underline">inner-context of the goal</span> is
also affected by the tactic command, and not only the hypotheses explicitly selected.
</p>

<p>
Moreover memo that the no-longer-lacked variables <code>y1</code> and <code>y2</code> may be cleared by
using the braces <code>{ .. }</code> option in the same line of textual command :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : (y1 - y2) =&gt; {y1 y2} z <span style="font-weight: bold; text-decoration: underline;">in</span> odd_y1y2 * .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x : nat
  x_gt1 : 1 &lt; x
  z : nat
  odd_y1y2 : odd z
  ============================
  2 &lt; z + x
</pre>
</div>
</div>

<div id="outline-container-org4f563dd" class="outline-4">
<h4 id="org4f563dd"><span class="section-number-4">5.3.4</span> equational-generalize</h4>
<div class="outline-text-4" id="text-5-3-4">
<p>
For the same goal <code>goal1</code> as above, oneself may describe some name for some
equation which links the term at the top of the stack before and after the
de-structuring command. This process is named <span class="underline">equational-generalize</span>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">goal3</span> (<span style="font-weight: bold; font-style: italic;">x y</span> : nat) (<span style="font-weight: bold; font-style: italic;">x_gt1</span> : 1 &lt; x) : odd y -&gt; 2 &lt; y + x .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  ============================
  odd y -&gt; 2 &lt; y + x
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : {-1}y (erefl y). <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">equational-generalize *</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">case</span> =&gt; [ | y' ] E <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">case *</span><span style="font-weight: bold; font-style: italic;">*)</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y : nat
  x_gt1 : 1 &lt; x
  ============================
  forall y0 : nat, y = y0 -&gt; odd y0 -&gt; 2 &lt; y0 + x

2 subgoals
  
  x, y : nat
  x_gt1 : 1 &lt; x
  E : y = 0
  ============================
  odd 0 -&gt; 2 &lt; 0 + x

subgoal 2 is:
 odd y'.+1 -&gt; 2 &lt; y'.+1 + x
</pre>

<p>
where the braces <code>{ .. }</code> option in <code>{-1}y</code> select which occurrences of the term <code>y</code>
shall be generalized or not generalized.
</p>

<p>
Alternatively, oneself may use the equation-option of the case command.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">case</span> E : y =&gt; [ | y' ] <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">equational-generalize case *</span><span style="font-weight: bold; font-style: italic;">*)</span>.
</pre>
</div>

<pre class="example">
2 subgoals
  
  x, y : nat
  x_gt1 : 1 &lt; x
  E : y = 0
  ============================
  forall y0 : nat, 0 = y0 -&gt; odd y0 -&gt; 2 &lt; y0 + x

subgoal 2 is:
 forall y0 : nat, y'.+1 = y0 -&gt; odd y0 -&gt; 2 &lt; y0 + x
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Abort</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org002d1c4" class="outline-4">
<h4 id="org002d1c4"><span class="section-number-4">5.3.5</span> lessorequal-generalize</h4>
<div class="outline-text-4" id="text-5-3-5">
<p>
For deduction by induction / recursion, during the induction step at <code>(S n)</code>
sometimes it is necessary to apply the induction hypothesis :
</p>
<ul class="org-ul">
<li>not on the immediate-predecessor <code>(S n) - 1</code> which is <code>n</code>, as commonly done,</li>
<li>but on some deeper-predecessor such as <code>(S n) - 4</code> which is <code>(n - 3)</code>.</li>
</ul>

<p>
Therefore oneself shall pre-process the goal by doing what is named
<span class="underline">equational-generalize</span>, and then do the induction <code>elim</code> command such to get what is
named <span class="underline">lessorequal-generalize induction</span> ( or <span class="underline">strong induction</span> ) . This arithmetic
question is some instance :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">stamps</span> n : 12 &lt;= n -&gt; <span style="text-decoration: underline;">exists</span> <span style="font-weight: bold; font-style: italic;">s4 s5</span>, s4 * 4 + s5 * 5 = n.
</pre>
</div>

<pre class="example">
1 subgoal
  
  n : nat
  ============================
  11 &lt; n -&gt; exists s4 s5 : nat, s4 * 4 + s5 * 5 = n
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : n {-2}n (leqnn n). <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">lessorequal-generalize *</span><span style="font-weight: bold; font-style: italic;">*)</span>
<span style="text-decoration: underline;">elim</span> =&gt; [ | m IHm ] <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">elim , then [  |  ] branching and intros *</span><span style="font-weight: bold; font-style: italic;">*)</span> .
<span style="font-weight: bold;">Show</span> 2 <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">shows subgoal 2 which has the stronger induction hypothesis *</span><span style="font-weight: bold; font-style: italic;">*)</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall n n0 : nat,
  n0 &lt;= n -&gt; 11 &lt; n0 -&gt; exists s4 s5 : nat, s4 * 4 + s5 * 5 = n0

2 subgoals
  
  ============================
  forall n : nat, n &lt;= 0 -&gt; 11 &lt; n -&gt; exists s4 s5 : nat, s4 * 4 + s5 * 5 = n

subgoal 2 is:
 forall n : nat,
 n &lt;= m.+1 -&gt; 11 &lt; n -&gt; exists s4 s5 : nat, s4 * 4 + s5 * 5 = n

subgoal 2 is:
  
  m : nat
  IHm : forall n : nat,
        n &lt;= m -&gt; 11 &lt; n -&gt; exists s4 s5 : nat, s4 * 4 + s5 * 5 = n
  ============================
  forall n : nat,
  n &lt;= m.+1 -&gt; 11 &lt; n -&gt; exists s4 s5 : nat, s4 * 4 + s5 * 5 = n
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Abort</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org42368ef" class="outline-4">
<h4 id="org42368ef"><span class="section-number-4">5.3.6</span> initial-accumulator-generalize</h4>
<div class="outline-text-4" id="text-5-3-6">
<p>
Another <i>embrouille</i> when attempting to do deduction by induction immediately /
suddenly / non-slowly is that some occurrences of initial-memories /
initial-accumulators in the goal may lack to be generalized earlier before doing the
actual induction later, because the value of the accumulator memory is going to
<i>change</i> when effecting the recursive calls and therefore the induction hypothesis
shall be general. This mediating pre-processing is named
<span class="underline">initial-accumulator-generalize</span>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Fixpoint</span> <span style="font-weight: bold;">addacc</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) (<span style="font-weight: bold; font-style: italic;">a</span> : nat) {<span style="font-weight: bold; text-decoration: underline;">struct</span> n} : nat :=
  <span style="font-weight: bold; text-decoration: underline;">if</span> n <span style="font-weight: bold; text-decoration: underline;">is</span> S n' <span style="font-weight: bold; text-decoration: underline;">then</span> addacc n' (S a) <span style="font-weight: bold; text-decoration: underline;">else</span> a .
<span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">add10</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) := addacc n 10 .
</pre>
</div>

<pre class="example">
addacc is defined
addacc is recursively defined (decreasing on 1st argument)

add10 is defined
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">add10S</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat) : add10 (S n) = S (add10 n).
<span style="text-decoration: underline;">rewrite</span> /add10.
</pre>
</div>

<pre class="example">
1 subgoal
  
  n : nat
  ============================
  add10 n.+1 = (add10 n).+1

1 subgoal
  
  n : nat
  ============================
  addacc n.+1 10 = (addacc n 10).+1
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : 10 .
</pre>
</div>

<pre class="example">
1 subgoal
  
  n : nat
  ============================
  forall n0 : nat, addacc n.+1 n0 = (addacc n n0).+1
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">elim</span> : n =&gt; [ // | n IHn ] a .
</pre>
</div>

<pre class="example">
1 subgoal
  
  n : nat
  IHn : forall n0 : nat, addacc n.+1 n0 = (addacc n n0).+1
  a : nat
  ============================
  addacc n.+2 a = (addacc n.+1 a).+1
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">simpl</span>.
<span style="text-decoration: underline;">apply</span>: (IHn (S a)).
</pre>
</div>

<pre class="example">
1 subgoal
  
  n : nat
  IHn : forall n0 : nat, addacc n.+1 n0 = (addacc n n0).+1
  a : nat
  ============================
  addacc n a.+2 = (addacc n a.+1).+1

No more subgoals.
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Qed</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org1aad7b2" class="outline-4">
<h4 id="org1aad7b2"><span class="section-number-4">5.3.7</span> forward-generalize, backward-generalize</h4>
<div class="outline-text-4" id="text-5-3-7">
<p>
In the section &lt;&lt; generalize &gt;&gt; above, it was seen that : oneself may pushe the
assumption which is the class / type of the lemma <code>goal1</code> on top of the now-present
goal, which is that oneself may <i>generalize the now-present goal by any deduction of
the class / type</i> of the lemma <code>goal1</code> . Yet another variation of this process is that
instead of using some already globally-memorized lemma <code>goal1</code>, oneself may command
<code>COQ</code> to create some new (internal) goal which is the class / type of <code>goal1</code> and then
to <i>generalize the old goal by any deduction of this class / type</i>. This process is
named <span class="underline">forward-generalize</span> (for the <code>have</code> command) or <span class="underline">backward-generalize</span> (for the
<code>suffices</code> command).
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">goal2</span> (<span style="font-weight: bold; font-style: italic;">x y1 y2</span> : nat) (<span style="font-weight: bold; font-style: italic;">x_gt1</span> : 1 &lt; x)
   (<span style="font-weight: bold; font-style: italic;">odd_y1y2</span> : odd (y1 - y2)) : 2 &lt; (y1 - y2) + x .
</pre>
</div>


<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  2 &lt; y1 - y2 + x
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">have</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span> (<span style="font-weight: bold; font-style: italic;">y</span> : nat), odd y -&gt; 2 &lt; y + x .
</pre>
</div>

<pre class="example">
2 subgoals
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  forall y : nat, odd y -&gt; 2 &lt; y + x

subgoal 2 is:
 (forall y : nat, odd y -&gt; 2 &lt; y + x) -&gt; 2 &lt; y1 - y2 + x
</pre>

<div class="org-src-container">
<pre class="src src-coq">by <span style="text-decoration: underline;">move</span> =&gt; [ // | y' ] /= _ ; <span style="text-decoration: underline;">apply</span> : ltn_addl x_gt1 .
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  (forall y : nat, odd y -&gt; 2 &lt; y + x) -&gt; 2 &lt; y1 - y2 + x
</pre>

<p>
Now the old goal, which has been generalized :
</p>

<div class="org-src-container">
<pre class="src src-coq">by <span style="text-decoration: underline;">apply</span>.
</pre>
</div>

<pre class="example">
No more subgoals.
</pre>

<p>
Alternatively, oneself may use the <code>suffices</code> command such to permute the
printing-precedence of the old goal or the new goal. Additionnally, one may
immediately solve the first-printed goal by postfixing the <code>have</code> or <code>suffices</code>
command as follows.
</p>

<div class="org-src-container">
<pre class="src src-coq">Restart.
</pre>
</div>

<pre class="example">
1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  2 &lt; y1 - y2 + x
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">suffices</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span> (<span style="font-weight: bold; font-style: italic;">y</span> : nat), odd y -&gt; 2 &lt; y + x.
  by <span style="text-decoration: underline;">apply</span>.

by <span style="text-decoration: underline;">move</span> =&gt; [ // | y' ] /= _ ; <span style="text-decoration: underline;">apply</span> : ltn_addl x_gt1 .
</pre>
</div>

<pre class="example">
2 subgoals
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  (forall y : nat, odd y -&gt; 2 &lt; y + x) -&gt; 2 &lt; y1 - y2 + x

subgoal 2 is:
 forall y : nat, odd y -&gt; 2 &lt; y + x

1 subgoal
  
  x, y1, y2 : nat
  x_gt1 : 1 &lt; x
  odd_y1y2 : odd (y1 - y2)
  ============================
  forall y : nat, odd y -&gt; 2 &lt; y + x

No more subgoals.
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Qed</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfe326c7" class="outline-4">
<h4 id="orgfe326c7"><span class="section-number-4">5.3.8</span> weakening-generalize</h4>
<div class="outline-text-4" id="text-5-3-8">
<p>
Whenever oneself lacks to prevent copy-paste of some parts of the deduction
programmer-script and also prevent copy-paste of some parts of the deduction
computer-term, then this may originate from the presence of permutation-symmetry in
the goal. For instance :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">leq_max</span> m n1 n2 : (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2) .
</pre>
</div>

<p>
Primo, memo that the conclusion of the goal it logically-equivalent to some change of
itself where the variables <code>n1</code> and <code>n2</code> have been permuted, in other words <code>((leq_max
m) n1 n2 &lt;-&gt; (leq_max m) n2 n1)</code> holds <code>by rewrite maxnC orbC</code>. Secondo, the deduction
starts by assuming each of the alternatives / cases of the destruction of the lemma
<code>leq_total n2 n1 : (n2 &lt;= n1) || (n1 &lt;= n2)</code> . Finally, memo that all of the
alternatives <code>(n2 &lt;= n1)</code> or <code>(n1 &lt;= n2)</code> are permutations of one single alternative,
for instance <code>(n2 &lt;= n1)</code> .
</p>

<p>
Therefore it shall be sufficient to deduce the conclusion under the assumption /
<span class="underline">weakener</span> <code>(n2 &lt;= n1)</code> .
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">suff</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">x y</span>, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y).
</pre>
</div>

<pre class="example">
2 subgoals
  
  m, n1, n2 : nat
  ============================
  (forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)) -&gt;
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)

subgoal 2 is:
 forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)
</pre>

<p>
In other words, refering to the goal as <code>G</code> and to the <span class="underline">weakener</span> as <code>W</code>, oneself has
to deduce that the <span class="underline">weakening</span> / <span class="underline">weakened goal</span> <code>(W -&gt; G)</code> is <i>sufficient</i> for the
goal <code>G</code> as such <code>((W -&gt; G) -&gt; G)</code> and then to deduce that the weakening <code>(W -&gt; G)</code>
indeed holds.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">move</span> : (leq_total n2 n1) =&gt; /orP <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">this apply-in query the view hints database *</span><span style="font-weight: bold; font-style: italic;">*)</span> .
</pre>
</div>

<pre class="example">
2 subgoals
  
  m, n1, n2 : nat
  ============================
  n2 &lt;= n1 \/ n1 &lt;= n2 -&gt;
  (forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)) -&gt;
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)

subgoal 2 is:
 forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">case</span> =&gt; y_le_x =&gt; /(_ _ _ y_le_x) .
</pre>
</div>

<pre class="example">
3 subgoals
  
  m, n1, n2 : nat
  y_le_x : n2 &lt;= n1
  ============================
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2) -&gt;
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)

subgoal 2 is:
 (m &lt;= maxn n2 n1) = (m &lt;= n2) || (m &lt;= n1) -&gt;
 (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)
subgoal 3 is:
 forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)
</pre>

<div class="org-src-container">
<pre class="src src-coq">  by [].
by <span style="text-decoration: underline;">move</span> =&gt; lem_perm; <span style="text-decoration: underline;">rewrite</span> maxnC orbC.
</pre>
</div>

<pre class="example">
2 subgoals
  
  m, n1, n2 : nat
  y_le_x : n1 &lt;= n2
  ============================
  (m &lt;= maxn n2 n1) = (m &lt;= n2) || (m &lt;= n1) -&gt;
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)

subgoal 2 is:
 forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)

1 subgoal
  
  m, n1, n2 : nat
  ============================
  forall x y : nat, y &lt;= x -&gt; (m &lt;= maxn x y) = (m &lt;= x) || (m &lt;= y)
</pre>

<p>
But wait ! Although the mathematical-sense did prevent the copy-paste of some parts of
the deduction programmer-script and also did prevent the copy-paste of some parts of
the deduction computer-term, memo that in the command <code>suff</code> above, oneself almost
copy-pasted the class / type / statement of the lemma <code>leq_max</code> which shall be
deduced.
</p>

<p>
Now to prevent this third variety of copy-paste, oneself may use the dedicated command
<code>wlog</code> which does this <span class="underline">weakening logic</span> (wlog). This weakening logic, from the angle
of view of permutations as-described-above, says that : one weakening (case) generates
(all other permutation-case-weakenings of) the general goal (which is
auto-permutative). The components of the weakening logic are : the weakener ( <code>n2 &lt;=
n1</code> , referred as <code>W</code>) , the occurrences of the variables in the weakened goal which
shall be generalized ( <code>n1</code> and <code>n2</code> ), the sufficiency ( <code>((W -&gt; G) -&gt; G)</code> ) of the
(only-formally-)weakened goal, and the deduction of the weakened goal <code>(W -&gt; G)</code>
(where the weakener has been optionally pre-introduced by some name).
</p>

<div class="org-src-container">
<pre class="src src-coq">Restart.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">wlog</span> le_n21 : n1 n2 / n2 &lt;= n1 .
</pre>
</div>

<pre class="example">
2 subgoals
  
  m, n1, n2 : nat
  ============================
  (forall n3 n4 : nat, n4 &lt;= n3 -&gt; (m &lt;= maxn n3 n4) = (m &lt;= n3) || (m &lt;= n4)) -&gt;
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)

subgoal 2 is:
 (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)
</pre>

<div class="org-src-container">
<pre class="src src-coq">by <span style="text-decoration: underline;">case</span>/orP : (leq_total n2 n1) =&gt; y_le_x =&gt; /(_ _ _ y_le_x) ;
  last <span style="text-decoration: underline;">move</span> =&gt; lem_perm; <span style="text-decoration: underline;">rewrite</span> maxnC orbC.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, n1, n2 : nat
  le_n21 : n2 &lt;= n1
  ============================
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4c8e639" class="outline-2">
<h2 id="org4c8e639"><span class="section-number-2">6</span> Deduction : data</h2>
<div class="outline-text-2" id="text-6">
<p>
Memo that the textual definition of classifications or classes such as <code>nat</code>
mentions some (outer) meta-logical primitives such as alternatives <code>.. | ..</code> or
inferences <code>.. -&gt; ..</code> . And the textual definition of the data type / class <code>nat</code> is
one of many ways of arranging-and-combining these meta-logical primitives. Oneself may
attempt to simply write, for each (outer) meta-logical primitive, some textual
definition which <span class="underline">internalize / mimick / simulate this (outer) meta-logical
primitive</span>.
</p>

<p>
This section is limited for (data) types/classes, the next outline section <a href="#org5343b48">7</a> is for classifications.
</p>
</div>

<div id="outline-container-org8f25d05" class="outline-3">
<h3 id="org8f25d05"><span class="section-number-3">6.1</span> inference</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The <span class="underline">pairing</span> ( or <span class="underline">and</span> &#x2026; ) data type internalizes the <span class="underline">inference</span> <code>.. -&gt; ..</code>
(outer) meta-logical primitive. This is communicated by the <code>Inductive</code> command which
does some <span class="underline">grammatical / inductive description / definition</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">prod</span> (<span style="font-weight: bold; font-style: italic;">A B</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) : <span style="font-weight: bold; text-decoration: underline;">Type</span> :=
  pair : A -&gt; (B -&gt; prod A B) .
</pre>
</div>
<p>
Primo as is common, the <span class="underline">constructor function</span> <code>pair</code> is the only <span class="underline">alternative</span> /
<span class="underline">case</span> to (recursively) <span class="underline">construct</span> / <span class="underline">build</span> data in this class, as shown for
instance in :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> (@pair bool nat (false) (S (S O))).
</pre>
</div>

<pre class="example">
(false, 2)
     : bool * nat
</pre>

<p>
The <code>COQ</code> <span class="underline">deduction / tactic command</span> corresponding to the constructor function
<code>pair</code> is <code>split</code> ( or <code>constructor 1</code> ) ; therefore this deduction script generates
the same deduction-term as the manually written deduction-term above :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">pair_false_2</span> : bool * nat .

  <span style="text-decoration: underline;">split</span>.
    exact: false.
  exact: (S (S O)).
<span style="font-weight: bold;">Defined</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  bool * nat

2 subgoals
  
  ============================
  bool

subgoal 2 is:
 nat

1 subgoal
  
  ============================
  nat

No more subgoals.
</pre>

<p>
Secondo as is common, the only alternate constructor <code>pair</code> of the class <code>prod</code>
<span class="underline">computationally or logically fulfill</span> / <span class="underline">support</span> this class, which is that it is
sufficient to focus / touch on these (recursively) constructored data when holding
this class, which is that any (random) data in the class may be such (recursively)
<span class="underline">destructed</span> / <span class="underline">eliminated</span> / <span class="underline">matched</span> / <span class="underline">filtered</span>. This is described by one
(grammatical) <span class="underline">destructor / match function</span> , as shown for instance in :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">fst</span> (<span style="font-weight: bold; font-style: italic;">A B</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) (<span style="font-weight: bold; font-style: italic;">p</span> : prod A B) : A :=
  <span style="font-weight: bold; text-decoration: underline;">match</span> p <span style="font-weight: bold; text-decoration: underline;">as</span> p0 <span style="font-weight: bold; text-decoration: underline;">in</span> prod _ _ <span style="font-weight: bold; text-decoration: underline;">return</span> A <span style="font-weight: bold; text-decoration: underline;">with</span>
    @pair _ _ a b =&gt; a
  <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>
<p>
The <code>COQ</code> <span class="underline">deduction / tactic command</span> corresponding to this (grammatical) destructor
/ match function is <code>case</code> ; therefore this deduction script generates the same
deduction-term as the manually written deduction-term above :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">fst</span> (<span style="font-weight: bold; font-style: italic;">A B</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) : prod A B -&gt; A .
  <span style="text-decoration: underline;">case</span>.
  <span style="text-decoration: underline;">move</span> =&gt; a b ; exact : a.
<span style="font-weight: bold;">Defined</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  A : Type
  B : Type
  ============================
  A * B -&gt; A

1 subgoal
  
  A : Type
  B : Type
  ============================
  A -&gt; B -&gt; A

No more subgoals.

case.
(move =&gt; a b; exact : a).

Defined.
</pre>
</div>
</div>

<div id="outline-container-orgde10255" class="outline-3">
<h3 id="orgde10255"><span class="section-number-3">6.2</span> classifying inference</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The <span class="underline">sigma</span> ( or <span class="underline">ex</span> &#x2026; ) data type internalizes the <span class="underline">classifying inference</span>
<code>forall .. , ..</code> (outer) meta-logical primitive; memo that the <i>identifier <code>x</code> does
not occur in the (inner-most) conclusion</i> of <code>existT</code> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">sigT</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) (<span style="font-weight: bold; font-style: italic;">P</span> : A -&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span>) : <span style="font-weight: bold; text-decoration: underline;">Type</span> :=
    existT : <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">x</span> : A, P x -&gt; @sigT A P .
</pre>
</div>
<p>
Primo, the <code>COQ</code> deduction / tactic command corresponding to the constructor function
<code>existT</code> is <code>exists</code> ( or <code>econstructor 1</code> or <code>eexists</code> ) :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">existsT_3_icons675inil</span> : @sigT nat ilist .
  <span style="text-decoration: underline;">exists</span> 3.
  exact: (icons 6 (icons 7 (icons 5 inil))).
  <span style="font-weight: bold;">Show</span> <span style="font-weight: bold;">Proof</span>.
<span style="font-weight: bold;">Defined</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  {x : nat &amp; ilist x}

1 subgoal
  
  ============================
  ilist 3

No more subgoals.

(existT ilist 3 (icons 6 (icons 7 (icons 5 inil))))
</pre>

<p>
Secondo, the <code>COQ</code> deduction / tactic command corresponding to the (shared)
(grammatical) destructor / match function is again <code>case</code> . The memo here is that the
input may be re-arranged when this input does not affect the classification of the
output.
</p>
</div>
</div>

<div id="outline-container-org259b9f1" class="outline-3">
<h3 id="org259b9f1"><span class="section-number-3">6.3</span> alternative</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The <span class="underline">sum</span> ( or <span class="underline">or</span> &#x2026; ) data type internalizes the <span class="underline">alternative</span> <code>.. | ..</code>
(outer) meta-logical primitive :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">sum</span> (<span style="font-weight: bold; font-style: italic;">A B</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) : <span style="font-weight: bold; text-decoration: underline;">Type</span> :=  
    inl : A -&gt; sum A B 
  | inr : B -&gt; sum A B .
</pre>
</div>
<p>
Primo, the <code>COQ</code> deduction / tactic command corresponding to the constructor function
<code>inl</code> is <code>left</code> ( or <code>constructor 1</code> ) and the <code>COQ</code> deduction / tactic command
corresponding to the constructor function <code>inr</code> is <code>right</code> ( or <code>constructor 2</code>
). Secondo, the <code>COQ</code> deduction / tactic command corresponding to the (shared)
(grammatical) destructor / match function is again <code>case</code> .
</p>

<p>
Additionally, the <span class="underline">unit</span> ( or <span class="underline">True</span> &#x2026; ) data type or <span class="underline">empty</span> ( or <span class="underline">False</span> &#x2026; )
data type correspondingly internalizes the <span class="underline">1-iterated or 0-iterated alternative</span>
<code>.. | ..</code> (outer) meta-logical primitive :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">unit</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span> :=  tt : unit .
<span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">empty</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span> :=           .
</pre>
</div>

<p>
Memo that zero constructor is sufficient to <span class="underline">computationally or logically
fulfill</span> / <span class="underline">support</span> the class <code>empty</code> , which is that it is sufficient to touch none
data when holding this class, which is that any (formal / grammatical) data in the
class may be such <span class="underline">destructed</span> / <span class="underline">eliminated</span> / <span class="underline">matched</span> / <span class="underline">filtered</span> as none
data. This is show for instance in :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="text-decoration: underline;">exfalso</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) : empty -&gt; A :=
  <span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">x</span> : empty =&gt;
    <span style="font-weight: bold; text-decoration: underline;">match</span> x <span style="font-weight: bold; text-decoration: underline;">with</span> <span style="font-weight: bold; text-decoration: underline;">end</span>.
</pre>
</div>

<pre class="example">
exfalso is defined
</pre>

<p>
Elsewhere this deduced lemma <code>exfalso</code> also says that there is always some inference
<code>empty -&gt; A</code> ; therefore if oneself wants to say that <code>A &lt;-&gt; empty</code> (that <code>A</code> is
empty), then it is sufficient to say that the inference type <code>A -&gt; empty</code> is
inhabitated. This type is commonly <i>shortened</i> as the definition <code>is_empty</code> ( or <code>not</code>
), instead of being described as some <i>grammatical / inductive</i> <i>definition /
description</i> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">is_empty</span> (<span style="font-weight: bold; font-style: italic;">A</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) := A -&gt; empty .
</pre>
</div>
</div>
</div>

<div id="outline-container-org58b1a43" class="outline-3">
<h3 id="org58b1a43"><span class="section-number-3">6.4</span> recursion</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Whenever oneself does some grammatical / inductive description / definition <code>idef1</code>
which recursively refers to itself <code>idef1</code> in the input for some constructor function,
then the <span class="underline">recursion</span> <code>fix .. := ..</code> grammatical (outer) meta-logical primitive is
automatically internalized as some <span class="underline">recursive elimination scheme / principle</span>
shortening-definition <code>idef1_rect</code> ( and <code>idef1_ind</code> and <code>idef1_rec</code> ). For instance,
the <code>nat</code> numbers :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">nat</span> := 
    O : nat 
  | S : nat -&gt; nat.
</pre>
</div>

<pre class="example">
nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> nat_rect.
</pre>
</div>

<pre class="example">
nat_rect = 
fun (P : nat -&gt; Type) (f : P 0) (f0 : forall n : nat, P n -&gt; P n.+1) =&gt;
fix F (n : nat) : P n :=
  match n as n0 return (P n0) with
  | 0 =&gt; f
  | n0.+1 =&gt; f0 n0 (F n0)
  end
     : forall P : nat -&gt; Type,
       P 0 -&gt; (forall n : nat, P n -&gt; P n.+1) -&gt; forall n : nat, P n

Argument scopes are [function_scope _ function_scope nat_scope]
</pre>

<p>
Memo that not all inductive descriptions are memorized by the <code>COQ</code> computer, for
example when some constructor has the form <code>(cons1 : (idef1 -&gt; type2) -&gt; idef1)</code> ;
this is such to prevent something as
</p>

<div class="org-src-container">
<pre class="src src-coq">Fail
<span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">empty_nonempty</span> := Convert (<span style="font-weight: bold; font-style: italic;">empty</span> : empty_nonempty -&gt; <span style="font-weight: bold; text-decoration: underline;">False</span>) .
</pre>
</div>

<pre class="example">
The command has indeed failed with message:
Non strictly positive occurrence of "empty_nonempty" in
 "(empty_nonempty -&gt; False) -&gt; empty_nonempty".
</pre>

<pre class="example">
Definition empty (nonempty : empty_nonempty) : False 
  := let: Convert empty' := nonempty in empty' nonempty.

Check empty (Convert empty). (* : False *)
</pre>

<p>
Primo as is common, the <code>COQ</code> deduction / tactic command corresponding to the
constructor function <code>O</code> is <code>constructor 1</code> ( or <code>apply: O</code> ) and the <code>COQ</code> deduction
/ tactic command corresponding to the constructor function <code>S</code> is <code>constructor 2</code> ( or
<code>apply: S</code> ).
</p>

<p>
Secondo as is common, the <code>COQ</code> deduction / tactic command
corresponding to the shared (grammatical) destructor / match function is again <code>case</code>.
</p>

<p>
Tertio as is common, the <code>COQ</code> deduction / tactic command corresponding to the
automatically-defined recursion scheme / principle <code>idef1_rect</code> is <code>elim</code> ( or <code>apply:
idef1_rect</code> ). For instance :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">addn0</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">m</span> : nat, m + 0 = m.
  <span style="text-decoration: underline;">elim</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall m : nat, m + 0 = m

2 subgoals
  
  ============================
  0 + 0 = 0

subgoal 2 is:
 forall n : nat, n + 0 = n -&gt; n.+1 + 0 = n.+1
</pre>

<p>
and the value of the input function <code>P : nat -&gt; Type</code> of the recursion scheme
<code>nat_rect</code> ( or <code>nat_ind</code> ) which is automatically inferred ( solved during
<span class="underline">higher-order unification</span> &#x2026; ) by the <code>elim</code> ( or <code>apply: nat_rect</code> ) command is
<code>(fun m' : nat =&gt; m' + 0 = m')</code> . Oneself may manually-synthesize <code>P</code> as follows (same
as the <code>pattern</code> command) :
</p>

<div class="org-src-container">
<pre class="src src-coq">Undo.
<span style="text-decoration: underline;">move</span> =&gt; m.
<span style="text-decoration: underline;">rewrite</span> -[_ = _]/((<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">m'</span> =&gt; _) m) .
<span style="text-decoration: underline;">apply</span> : nat_rect m <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">or elim : m *</span><span style="font-weight: bold; font-style: italic;">*)</span> .
</pre>
</div>

<pre class="example">
1 subgoal
  
  ============================
  forall m : nat, m + 0 = m

1 subgoal
  
  m : nat
  ============================
  m + 0 = m

1 subgoal
  
  m : nat
  ============================
  (fun m' : nat =&gt; m' + 0 = m') m

2 subgoals
  
  ============================
  0 + 0 = 0

subgoal 2 is:
 forall n : nat, n + 0 = n -&gt; n.+1 + 0 = n.+1
</pre>
</div>
</div>
</div>

<div id="outline-container-org5343b48" class="outline-2">
<h2 id="org5343b48"><span class="section-number-2">7</span> Deduction : classification</h2>
<div class="outline-text-2" id="text-7">
<p>
Memo that the textual definition of classifications or classes such as <code>nat</code>
mentions some (outer) meta-logical primitives such as alternatives <code>.. | ..</code> or
inferences <code>.. -&gt; ..</code> . And the textual definition of the data type / class <code>nat</code> is
one of many ways of arranging-and-combining these meta-logical primitives. Oneself may
attempt to simply write, for each (outer) meta-logical primitive, some textual
definition which <span class="underline">internalize / mimick / simulate this (outer) meta-logical
primitive</span>.
</p>

<p>
This section is the continuation, for classifications, of the preceding outline
section <a href="#org4c8e639">6</a> for (data) types/classes.
</p>
</div>

<div id="outline-container-org6116e68" class="outline-3">
<h3 id="org6116e68"><span class="section-number-3">7.1</span> meta-computation</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The <span class="underline">equality classifier</span> internalizes <span class="underline">(outer) meta-computation</span>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Print</span> Coq.Init.Logic.eq.
</pre>
</div>

<pre class="example">
Inductive eq (A : Type) (x : A) : A -&gt; Prop :=  eq_refl : x = x

For eq: Argument A is implicit and maximally inserted
For eq_refl, when applied to no arguments:
  Arguments A, x are implicit and maximally inserted
For eq_refl, when applied to 1 argument:
  Argument A is implicit
For eq: Argument scopes are [type_scope _ _]
For eq_refl: Argument scopes are [type_scope _]
</pre>

<p>
From the meta (outer) angle of view, <code>eq_refl</code> is some primitive <span class="underline">deduction / proof
term / value</span> which says ( asserts / deduces / proves ) that the parameter <code>x</code> is "eq"
("equal") to any index-argument <code>y</code> which <span class="underline">by-computation-is</span> ( <span class="underline">by-convertibility-is</span>
) <code>x</code> ; and <code>eq_refl</code> is precisely-classified inside <code>@eq A x y</code> by any index-argument
<code>y</code> which by-computation-is <code>x</code> . And the <code>COQ</code> deduction / tactic command
corresponding to the constructor function <code>eq_refl</code> is <code>reflexivity</code> .
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> @Logic.eq_refl nat (3 + 2) : @Logic.eq nat (3 + 2) (S (S (1 + 2))).
</pre>
</div>

<pre class="example">
erefl (3 + 2) : 3 + 2 = (1 + 2).+2
     : 3 + 2 = (1 + 2).+2
</pre>

<p>
Moreover, deductions may be combinated in complex ways; which is that oneself may
arrive at <code>@eq A x y</code> by more-complex combinaisons ( <span class="underline">by-logical-deduction</span> ) beyond
precisely-one-primitive-deduction ( <span class="underline">by-computation</span> ) <code>eqrefl</code> .
</p>

<p>
From the meta (outer) angle of view, the description of "eq" above may be read as :
</p>

<pre class="example">
Inductive eq (A : Type) (x : A) : A -&gt; Type :=
  eq_refl : forall ?y which by-computation-is x , @eq A x ?y .
</pre>

<p>
Now the <i>elimination scheme</i> <code>eq_rect</code> ( or <code>eq_ind</code> ), which shorten the
(grammatical) destructor/match function, has the sense of (congruent) rewriting /
casting / transport.
</p>

<pre class="example">
eq_rect = 
fun (A : Type) (x : A) (P : A -&gt; Type) (f : P x) (y : A) (e : x = y) =&gt;
match e in (_ = y0) return (P y0) with
| erefl _ _ =&gt; f
end
     : forall (A : Type) (x : A) (P : A -&gt; Type),
       P x -&gt; forall y : A, x = y -&gt; P y

Argument A is implicit
Argument scopes are [type_scope _ function_scope _ _ _]
</pre>

<p>
And as is common, the <code>COQ</code> deduction / tactic command corresponding to this
(grammatical) destructor / match function is <code>case</code> . Moreover the alternative command
<code>rewrite</code> is container of the <code>case</code>-command-for-equalities and enables more-complex
pre-processing and post-processing. For example, one such pre-processing is doing
more-easily the same generalization pre-processing which is enabled by the
<span class="underline">generalizing-case command</span> <code>case : .. / ..</code> when <i>the index-argument of the equality
classification is not some variable</i> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">lemma1337</span> (<span style="font-weight: bold; font-style: italic;">P</span> : nat -&gt; nat -&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span>)
  (<span style="font-weight: bold; font-style: italic;">c</span> : nat) (<span style="font-weight: bold; font-style: italic;">pcc</span> : P c (c * c)) (<span style="font-weight: bold; font-style: italic;">Hc</span> : c + c = 0)
  (<span style="font-weight: bold; font-style: italic;">Heq</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span> (<span style="font-weight: bold; font-style: italic;">n</span> : nat), c + c = n - n -&gt; c = n * 0) n1 n2 
  : P (n1 * 0) ((n2 * 0) * (n2 * 0)) .
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">case</span> : ( n1 * _ ) / Heq.

Undo.
<span style="text-decoration: underline;">rewrite</span> -[ n1 * _ ]Heq.

Undo.
<span style="text-decoration: underline;">rewrite</span> -Heq.
</pre>
</div>

<pre class="example">
2 subgoals
  
  P : nat -&gt; nat -&gt; Type
  c : nat
  pcc : P c (c * c)
  Hc : c + c = 0
  n1, n2 : nat
  ============================
  c + c = n1 - n1

subgoal 2 is:
 P c (n2 * 0 * (n2 * 0))

1 subgoal
  
  P : nat -&gt; nat -&gt; Type
  c : nat
  pcc : P c (c * c)
  Hc : c + c = 0
  Heq : forall n : nat, c + c = n - n -&gt; c = n * 0
  n1, n2 : nat
  ============================
  P (n1 * 0) (n2 * 0 * (n2 * 0))

2 subgoals
  
  P : nat -&gt; nat -&gt; Type
  c : nat
  pcc : P c (c * c)
  Hc : c + c = 0
  Heq : forall n : nat, c + c = n - n -&gt; c = n * 0
  n1, n2 : nat
  ============================
  P c (n2 * 0 * (n2 * 0))

subgoal 2 is:
 c + c = n1 - n1

1 subgoal
  
  P : nat -&gt; nat -&gt; Type
  c : nat
  pcc : P c (c * c)
  Hc : c + c = 0
  Heq : forall n : nat, c + c = n - n -&gt; c = n * 0
  n1, n2 : nat
  ============================
  P (n1 * 0) (n2 * 0 * (n2 * 0))
</pre>

<p>
where, in the third command <code>rewrite -Heq.</code> , the subterms to rewrite are <span class="underline">all the
occurrences of the first match of the filter</span> which has been inferred ( here <code>( _ * 0
)</code> ) from the right-hand-side of the equality <code>Heq</code>.
</p>

<p>
And the rest of the modifiers for the <code>rewrite</code> command explains itself :
</p>

<div class="org-src-container">
<pre class="src src-coq">Fail <span style="text-decoration: underline;">rewrite</span> -{2}Heq.
<span style="text-decoration: underline;">rewrite</span> -{2}[ <span style="font-weight: bold; text-decoration: underline;">in</span> X <span style="font-weight: bold; text-decoration: underline;">in</span> P _ X ]Heq.
</pre>
</div>

<pre class="example">
The command has indeed failed with message:
Ltac call to "rewrite (ssrrwargs) (ssrclauses)" failed.
Error: Only 1 &lt; 2 occurence of the RHS
    (n1 * 0)
of Heq
1 subgoal
  
  P : nat -&gt; nat -&gt; Type
  c : nat
  pcc : P c (c * c)
  Hc : c + c = 0
  Heq : forall n : nat, c + c = n - n -&gt; c = n * 0
  n1, n2 : nat
  ============================
  P (n1 * 0) (n2 * 0 * (n2 * 0))
</pre>

<p>
where any <code>[ in .. ]</code> modifier such as <code>[ in X in P _ X ]</code> is named some
<span class="underline">imprecise-contextual filter</span>, and any <code>{ .. }</code> modifier such as <code>{2}</code> is named some
<span class="underline">occurence modifier</span>, further more :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> -{2}[ (_ * 0) <span style="font-weight: bold; text-decoration: underline;">in</span> X <span style="font-weight: bold; text-decoration: underline;">in</span> P _ X ]Heq
  ?Hc ?subnn // <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">1 branch *</span><span style="font-weight: bold; font-style: italic;">*)</span>
  -!Heq // <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">trunk *</span><span style="font-weight: bold; font-style: italic;">*)</span> 
  Hc subnn // <span style="font-weight: bold; font-style: italic;">(** </span><span style="font-weight: bold; font-style: italic;">2 branches *</span><span style="font-weight: bold; font-style: italic;">*)</span> .
</pre>
</div>

<pre class="example">
No more subgoals.
</pre>

<p>
where any <code>[ ( .. ) in .. ]</code> modifier such as <code>[ (_ * 0) in X in P _ X ]</code> is named
some <span class="underline">more-precise-contextual filter</span> , where the lemma <code>subnn : forall n : nat, n - n
= 0</code> , and further more : where the sequencing of the <code>?</code> modifier and the <code>//</code>
modifier is sometimes used
</p>
<ul class="org-ul">
<li>to early solve / close any generated <span class="underline">branching / side conditions</span> of the
rewriting-equation, and then continue with the <span class="underline">trunk goal</span>, or</li>
<li>to early solve / close the <span class="underline">trunk goal</span> and then continue with the <span class="underline">branching / side
conditions</span>.</li>
</ul>

<p>
Elsewhere, because shortening-definitions ( such as <code>leq</code> ) may be <span class="underline">unfolded</span>
by-computation ( <i>delta rule</i> &#x2026; ), and because by-computation ( <code>eq_refl</code> ) is some
(primitive) deduction of equality, therefore the <code>rewrite</code> command may be inputed the
name of some shortening-definition which shall be <span class="underline">unfold-rewritten</span> / <span class="underline">unfolded</span> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">leq_mul2l</span> m n1 n2 :
  (m * n1 &lt;= m * n2) = (eqn m 0) || (leq n1 n2).
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * n1 &lt;= m * n2) = eqn m 0 || (n1 &lt;= n2)
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> [<span style="font-weight: bold; text-decoration: underline;">in</span> LHS]/leq.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * n1 - m * n2 == 0) = eqn m 0 || (n1 &lt;= n2)
</pre>

<p>
where the <i>imprecise contextual filter</i> <code>[ in LHS ]</code> is short notation for <code>[ in X in
X = _ ]</code> , and the <code>==</code> notation is some more convoluted way ("canonical structures")
of saying <code>eqn</code> &#x2026;
</p>

<p>
More generally, the <code>rewrite</code> command ( and the corresponding <code>change</code> command &#x2026; )
may be used to <span class="underline">change-rewrite</span> / <span class="underline">change</span> / <span class="underline">replace</span> some subterm of the goal by
another term whenever these two terms are equal-by-computation :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> -[n1]/(addn 0 n1).
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * (0 + n1) - m * n2 == 0) = eqn m 0 || (0 + n1 &lt;= n2)
</pre>

<p>
Another angle of view of the change-rewrite command is that it <span class="underline">fold-rewrite</span> / <span class="underline">fold</span>
the <i>head constant</i> of the destination term (filter), where the inferred filter which
shall be matched in the goal is the filter which is obtained after unfolding this head
constant of the destination filter.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> -/(leq _ _).
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * (0 + n1) &lt;= m * n2) = eqn m 0 || (0 + n1 &lt;= n2)
</pre>
</div>
</div>

<div id="outline-container-orgc5b14c7" class="outline-3">
<h3 id="orgc5b14c7"><span class="section-number-3">7.2</span> boolean-computational reflection</h3>
<div class="outline-text-3" id="text-7-2">
<p>
The <span class="underline">reflect classifier</span> internalizes the <span class="underline">decidability of decidable types
(predicates)</span>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">reflect</span> (<span style="font-weight: bold; font-style: italic;">P</span> : <span style="font-weight: bold; text-decoration: underline;">Type</span>) : bool -&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span> :=
| ReflectT (<span style="font-weight: bold; font-style: italic;">p</span> : P) : reflect P true
| ReflectF (<span style="font-weight: bold; font-style: italic;">np</span> : P -&gt; <span style="font-weight: bold; text-decoration: underline;">False</span>) : reflect P false.
</pre>
</div>

<pre class="example">
reflect is defined
reflect_rect is defined
reflect_ind is defined
reflect_rec is defined
</pre>

<p>
This reflect classifier <code>reflect P b</code> uses some binary / boolean (inner)
index-argument <code>b</code> to classify the presence or absence of data in some (outer)
parameter type <code>P</code>. The <i>elimination scheme</i> <code>reflect_rect</code> contains some sense of
<i>automatic substitution</i> of the occurrences of the index-argument in the goal; this is
comparable to the equality classifier.
</p>

<p>
Now instead of <i>rewrite lemmas</i> for the equality classifier, onself has <i>reflection
lemmas</i> for the reflect classifier. For instance, which also shows that the inputs <code>P</code>
and <code>b</code> in any textual description <code>reflect P b</code> may be memorized as <i>logical
predicate</i> and <i>boolean predicate</i> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> andP.
</pre>
</div>

<pre class="example">
andP : forall b1 b2 : bool, reflect (b1 /\ b2) (b1 &amp;&amp; b2)

Arguments b1, b2 are implicit and maximally inserted
Argument scopes are [bool_scope bool_scope]
andP is opaque
Expands to: Constant mathcomp.ssreflect.ssrbool.andP
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">example37</span> a b : a &amp;&amp; b ==&gt; (a == b).

  <span style="text-decoration: underline;">case</span> : andP .
</pre>
</div>

<pre class="example">
1 subgoal
  
  a, b : bool
  ============================
  a &amp;&amp; b ==&gt; (a == b)

2 subgoals
  
  a, b : bool
  ============================
  a /\ b -&gt; true ==&gt; (a == b)

subgoal 2 is:
 ~ (a /\ b) -&gt; false ==&gt; (a == b)
</pre>

<p>
Memo that the equality classifier has some alternative command <code>rewrite</code> which is
container of the <span class="underline">generalizing-case command</span> <code>case : .. / ..</code> for equalities, but
there is no such command for the <code>reflect</code> classifier and the generalizing-case
command <code>case : .. / ..</code> shall be queried directly.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">example13</span> a b : (a || ~~ a) &amp;&amp; (a &amp;&amp; b ==&gt; (a == b)).

  <span style="text-decoration: underline;">case</span> E: (a &amp;&amp; _) / andP.
</pre>
</div>

<pre class="example">
1 subgoal
  
  a, b : bool
  ============================
  (a || ~~ a) &amp;&amp; (a &amp;&amp; b ==&gt; (a == b))
</pre>

<p>
And oneself shall use these lemmas if oneself lacks to deduce new reflection lemmas :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> idP.
<span style="font-weight: bold;">About</span> iffP.
</pre>
</div>

<pre class="example">
idP : forall b1 : bool, reflect b1 b1

Argument b1 is implicit and maximally inserted
Argument scope is [bool_scope]
idP is opaque
Expands to: Constant mathcomp.ssreflect.ssrbool.idP

iffP :
forall (P Q : Prop) (b : bool),
reflect P b -&gt; (P -&gt; Q) -&gt; (Q -&gt; P) -&gt; reflect Q b

Arguments P, Q, b are implicit
Argument scopes are [type_scope type_scope bool_scope _ function_scope
  function_scope]
iffP is opaque
Expands to: Constant mathcomp.ssreflect.ssrbool.iffP
</pre>
</div>
</div>

<div id="outline-container-org9b17275" class="outline-3">
<h3 id="org9b17275"><span class="section-number-3">7.3</span> boolean simultaneous-substitution</h3>
<div class="outline-text-3" id="text-7-3">
<p>
The <span class="underline">compare_nat classifier</span> internalizes the <span class="underline">totality of the ordering on
numbers</span>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">compare_nat</span> (<span style="font-weight: bold; font-style: italic;">m n</span> : nat) : bool -&gt; bool -&gt; bool -&gt; <span style="font-weight: bold; text-decoration: underline;">Set</span> :=
    CompareNatLt : m &lt; n -&gt; compare_nat m n true false false
  | CompareNatGt : n &lt; m -&gt; compare_nat m n false true false
  | CompareNatEq : m = n -&gt; compare_nat m n false false true .
</pre>
</div>

<pre class="example">
compare_nat is defined
compare_nat_rect is defined
compare_nat_ind is defined
compare_nat_rec is defined
</pre>

<p>
And with this comparaison lemma <code>ltngtP</code> , it may be used to do <span class="underline">boolean
simultaneous-substitution</span> of all the occurrences of <code>(m &lt; n)</code> and <code>(n &lt; m)</code> and <code>(m
== n)</code> in the goal :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Check</span> ltngtP : <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">m n</span>, compare_nat m n (m &lt; n) (n &lt; m) (m == n) .
</pre>
</div>

<p>
Another comparaison classifier is <code>leq_xor_gtn</code> , which comes with some comparaison
lemma <code>leqP</code> .
</p>
</div>
</div>

<div id="outline-container-org3d7b767" class="outline-3">
<h3 id="org3d7b767"><span class="section-number-3">7.4</span> recursion</h3>
<div class="outline-text-3" id="text-7-4">
<p>
For <i>classifiers</i>, as for <i>classes</i>, the <span class="underline">recursion</span> <code>fix .. := ..</code> grammatical
(outer) meta-logical primitive is automatically internalized as some <span class="underline">recursive
elimination scheme</span> shortening-definition. For instance, the <code>ilist</code> indexed lists :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Inductive</span> <span style="font-weight: bold;">ilist</span> : nat -&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span> := 
    inil : ilist 0 
  | icons : nat -&gt; <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">m</span> : nat, ilist m -&gt; ilist (S m).
</pre>
</div>

<pre class="example">
ilist is defined
ilist_rect is defined
</pre>

<pre class="example">
ilist_rect = 
fun (P : forall n : nat, ilist n -&gt; Type) (f : P 0 inil)
  (f0 : forall (n m : nat) (i : ilist m), P m i -&gt; P m.+1 (icons n i)) =&gt;
fix F (n : nat) (i : ilist n) {struct i} : P n i :=
  match i as i0 in (ilist n0) return (P n0 i0) with
  | inil =&gt; f
  | @icons n0 m i0 =&gt; f0 n0 m i0 (F m i0)
  end
     : forall P : forall n : nat, ilist n -&gt; Type,
       P 0 inil -&gt;
       (forall (n m : nat) (i : ilist m), P m i -&gt; P m.+1 (icons n i)) -&gt;
       forall (n : nat) (i : ilist n), P n i

Arguments P, n are implicit
Argument scopes are [function_scope _ function_scope nat_scope _]
</pre>

<p>
In contrast to classes, for classifiers, the <code>COQ</code> deduction / tactic command
corresponding to the shared (grammatical) destructor / match function is some more
complex <span class="underline">generalizing-case</span> command <code>case : .. / ..</code> because <i>the index-argument of
the classifier-which-shall-be-destructed may not be some variable-identifier</i>. Memo
that the <code>rewrite</code> command is some container of this same generalizing-case command
for the <i>equality classifier</i>.
</p>

<p>
For instance, this function <code>ihead_ibehead</code> input from some indexed list whose index
(which simulates the <i>real size</i> number of items in the list) is some positive number
and output the pair where the first component is the head item of the list and the
second component is the rest of the list :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">ihead_ibehead</span> (<span style="font-weight: bold; font-style: italic;">m</span> : nat) (<span style="font-weight: bold; font-style: italic;">l</span> : ilist (S m)) : nat * (ilist m).

<span style="text-decoration: underline;">case</span> Heq : (S _) / l =&gt; [ | j m' l' ] .
</pre>
</div>

<pre class="example">
1 subgoal
  
  m : nat
  l : ilist m.+1
  ============================
  nat * ilist m

2 subgoals
  
  m : nat
  Heq : m.+1 = 0
  ============================
  nat * ilist m

subgoal 2 is:
 nat * ilist m
</pre>

<p>
Oneself shall <span class="underline">exfalso</span> this first goal :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">suff</span> : <span style="font-weight: bold; text-decoration: underline;">False</span> by exact: (<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">f</span> : <span style="font-weight: bold; text-decoration: underline;">False</span> =&gt; <span style="font-weight: bold; text-decoration: underline;">match</span> f <span style="font-weight: bold; text-decoration: underline;">with</span> <span style="font-weight: bold; text-decoration: underline;">end</span>).
</pre>
</div>

<pre class="example">
2 subgoals
  
  m : nat
  Heq : m.+1 = 0
  ============================
  False

subgoal 2 is:
 nat * ilist m
</pre>

<p>
then the equation <code>Heq : m.+1 = 0</code> shall enable rewrite / transport / cast of data
from any origin class <code>A</code> corresponding to <code>m.+1</code> into any other destination class <code>B</code>
corresponding <code>0</code> , because <code>m.+1</code> is <span class="underline">discriminable / distinguishable</span> from <code>0</code> such
that oneself is able to <i>program such classification</i> of <code>A</code> by <code>m.+1</code> and <code>B</code> by
<code>0</code>. Here the destination class <code>B</code> is <code>False</code> and the origin class is <code>True</code> with its
data <code>I</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> -[<span style="font-weight: bold; text-decoration: underline;">False</span>]/((<span style="font-weight: bold; text-decoration: underline;">fun</span> <span style="font-weight: bold; font-style: italic;">n</span> : nat =&gt; <span style="font-weight: bold; text-decoration: underline;">match</span> n <span style="font-weight: bold; text-decoration: underline;">with</span>
                      | _.+1 =&gt; <span style="font-weight: bold; text-decoration: underline;">True</span>
                      | 0 =&gt; <span style="font-weight: bold; text-decoration: underline;">False</span>
                      <span style="font-weight: bold; text-decoration: underline;">end</span>) 0).
</pre>
</div>

<pre class="example">
2 subgoals
  
  m : nat
  Heq : m.+1 = 0
  ============================
  (fun n : nat =&gt; match n with
                  | 0 =&gt; False
                  | _.+1 =&gt; True
                  end) 0

subgoal 2 is:
 nat * ilist m
</pre>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> -[0]Heq.
exact : I.
</pre>
</div>

<pre class="example">
2 subgoals
  
  m : nat
  Heq : m.+1 = 0
  ============================
  True

subgoal 2 is:
 nat * ilist m

1 subgoal
  
  m, j, m' : nat
  l' : ilist m'
  Heq : m.+1 = m'.+1
  ============================
  nat * ilist m
</pre>

<p>
Alternatively oneself may use the <code>by []</code> composite-command to automatically deduce
this <i>discrimination lemma</i> :
</p>

<div class="org-src-container">
<pre class="src src-coq">Undo 4. 
by [].
</pre>
</div>

<pre class="example">
2 subgoals
  
  m : nat
  Heq : m.+1 = 0
  ============================
  nat * ilist m

subgoal 2 is:
 nat * ilist m

1 subgoal
  
  m, j, m' : nat
  l' : ilist m'
  Heq : m.+1 = m'.+1
  ============================
  nat * ilist m
</pre>

<p>
Now the second goal starts by deducing some new equation from the old equation <code>Heq</code>
by beholding the <span class="underline">injectivity of constructor functions</span> ( here the successor
constructor function has some <i>named cancelling function</i> which is the predecessor
function <code>_ .-1</code> )
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">have</span> Heq_injective : m.+1.-1 = m'.+1.-1 by <span style="text-decoration: underline;">rewrite</span> Heq.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, j, m' : nat
  l' : ilist m'
  Heq : m.+1 = m'.+1
  Heq_injective : m.+1.-1 = m'.+1.-1
  ============================
  nat * ilist m
</pre>

<p>
Alternatively oneself may use the <code>case</code> command to automatically deduce this
injectivity lemma :
</p>

<div class="org-src-container">
<pre class="src src-coq">Undo. <span style="text-decoration: underline;">case</span> : Heq =&gt; Heq_injective.

<span style="text-decoration: underline;">rewrite</span> [m]Heq_injective.
exact: (j , l').
<span style="font-weight: bold;">Defined</span>.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, j, m' : nat
  l' : ilist m'
  Heq : m.+1 = m'.+1
  ============================
  nat * ilist m

1 subgoal
  
  m, j, m' : nat
  l' : ilist m'
  Heq_injective : m = m'
  ============================
  nat * ilist m

1 subgoal
  
  m, j, m' : nat
  l' : ilist m'
  Heq_injective : m = m'
  ============================
  nat * ilist m'

No more subgoals.

case  Heq: (S _) / l =&gt; [|j m' l'].
 by [  ].

 case : Heq =&gt; Heq_injective.
 rewrite [m]Heq_injective.
 exact : (j, l').

Defined.
</pre>

<p>
In contrast to classes, for classifiers, the <code>COQ</code> deduction / tactic command
corresponding to the recursive elimination scheme is some more complex
<span class="underline">generalizing-elimination</span> command <code>elim : .. / ..</code> because <i>the index-argument of the
classifier-which-shall-be-destructed may not be some variable-identifier</i>.
</p>

<p>
Finally, some lemmas may be solved more-sensibly if the deduction uses some
<span class="underline">alternative recursion scheme which is manually-defined by the programmer</span>. This is
done by using the <code>elim / scheme1</code> command. For instance, oneself may view <code>addn</code> as
some classification which is its <i>graph</i> and deduce the manually-defined recursion
schema :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">addn_classifier</span> (<span style="font-weight: bold; font-style: italic;">m</span> : nat) (<span style="font-weight: bold; font-style: italic;">P</span> : nat -&gt; nat -&gt; <span style="font-weight: bold; text-decoration: underline;">Prop</span>) (<span style="font-weight: bold; font-style: italic;">H</span>: P 0 m)
 (<span style="font-weight: bold; font-style: italic;">H0</span> : <span style="font-weight: bold; text-decoration: underline;">forall</span>  <span style="font-weight: bold; font-style: italic;">p</span> : nat, P p (addn p m) -&gt; P p.+1 (addn p m).+1)
 : <span style="font-weight: bold; text-decoration: underline;">forall</span> <span style="font-weight: bold; font-style: italic;">n</span> : nat, P n (addn n m) .

<span style="text-decoration: underline;">elim</span>; [<span style="text-decoration: underline;">apply</span>: H | <span style="text-decoration: underline;">apply</span>: H0]. <span style="font-weight: bold;">Qed</span>.
</pre>
</div>

<p>
Then the deduction of this associativity lemma is smoother because some extra
simplification-computation step is avoided &#x2026;
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">exF</span> x y z: addn z (addn y x) = addn (addn z y) x.
</pre>
</div>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">elim</span>/addn_classifier : z / (addn z _) .
</pre>
</div>

<pre class="example">
2 subgoals
  
  x, y : nat
  ============================
  y + x = 0 + y + x

subgoal 2 is:
 forall p : nat, p + (y + x) = p + y + x -&gt; (p + (y + x)).+1 = p.+1 + y + x
</pre>

<div class="org-src-container">
<pre class="src src-coq">  by [].
by <span style="text-decoration: underline;">move</span> =&gt; p -&gt; .
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf9d80cf" class="outline-2">
<h2 id="orgf9d80cf"><span class="section-number-2">8</span> Review of some long deductions</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgd2c8b51" class="outline-3">
<h3 id="orgd2c8b51"><span class="section-number-3">8.1</span> Accumulating division</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Accumulating (euclidian) division is
</p>
<ul class="org-ul">
<li>iterating subtraction on some input data until the remaining input data ( the
<span class="underline">remainder</span> ) is too small for another substraction, and simultaneously</li>
<li>memorizing the number of iterations ( the <span class="underline">quotient</span> ) into some extra
accumulator-memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">edivn_rec</span> d :=
  <span style="font-weight: bold; text-decoration: underline;">fix</span> loop m q := <span style="font-weight: bold; text-decoration: underline;">if</span> m - d <span style="font-weight: bold; text-decoration: underline;">is</span> m'.+1 <span style="font-weight: bold; text-decoration: underline;">then</span> loop m' q.+1 <span style="font-weight: bold; text-decoration: underline;">else</span> (q, m).

<span style="font-weight: bold;">Definition</span> <span style="font-weight: bold;">edivn</span> m d := <span style="font-weight: bold; text-decoration: underline;">if</span> d &gt; 0 <span style="font-weight: bold; text-decoration: underline;">then</span> edivn_rec d.-1 m 0 <span style="font-weight: bold; text-decoration: underline;">else</span> (0, m).
</pre>
</div>

<p>
Memo that And the <code>COQ</code> computer is very good at detecting that the accumulator <code>m</code> is
degrading for the <code>fix</code> command, although the term <code>m'</code> is not some
<i>immediate-subterm</i> of <code>m</code>. Elsewhere the <code>edivn</code> program handles the case of some
zero divisor, producing the dummy pair <code>(0,m)</code> for the quotient and the remainder
correspondingly.
</p>

<p>
It is sometimes useful to describe and deduce unfolding equations like this one :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">edivn_recE</span> d m q :
  edivn_rec d m q = <span style="font-weight: bold; text-decoration: underline;">if</span> m - d <span style="font-weight: bold; text-decoration: underline;">is</span> m'.+1 <span style="font-weight: bold; text-decoration: underline;">then</span> edivn_rec d m' q.+1 <span style="font-weight: bold; text-decoration: underline;">else</span> (q,m).

 by <span style="text-decoration: underline;">case</span>: m. <span style="font-weight: bold;">Qed</span>.
</pre>
</div>

<p>
Indeed the simplification tactic <code>/=</code> ( or <code>simpl</code> ) may unfold excessively than
whatever is wanted. Rewriting with such equations enables finer communcation of how
many unfold steps shall be performed.
</p>

<p>
Now oneself shall deduce that the <code>edivn</code> <i>program satisfies some given property /
specification</i> :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">Lemma</span> <span style="font-weight: bold;">edivnP</span> m d (ed := edivn m d) :
  ((d &gt; 0) ==&gt; (ed.2 &lt; d)) &amp;&amp; (m == ed.1 * d + ed.2).
</pre>
</div>

<p>
The type of this lemma uses some <span class="underline">let-in</span> / <span class="underline">behold</span> / <span class="underline">locally-defined</span> parameter /
hypothesis <code>( .. := ..)</code> which translates as some <code>let .. := .. in ..</code> term.
</p>

<p>
Oneself shall deduce this lemma by lessorequal-generalizing induction ( strong
induction ) because the recursive query of the function <code>edivn_recE</code> is made at some
deeper nonimmediate-subterm of the accumulator.
</p>

<p>
Primo, the case of <code>d</code> being zero is solved, where oneself uses the <i>revert-then-intro
contextualization</i> <code>.. in ..</code> of the command <code>case</code>.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">case</span>: d =&gt; [|d /=] <span style="font-weight: bold; text-decoration: underline;">in</span> ed *; first by <span style="text-decoration: underline;">rewrite</span> eqxx.
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, d : nat
  ed := edivn m d.+1 : nat * nat
  ============================
  (ed.2 &lt; d.+1) &amp;&amp; (m == ed.1 * d.+1 + ed.2)
</pre>

<p>
Then the next commands shall do some pre-processing before the induction by unfolding
the definition of edivn ( to expose the initial value of the accumulators of
<code>edivn_rec</code> ) and makes the <i>invariant of the division loop</i> explicit replacing <code>m</code> by
<code>(0 * d.+1 + m)</code> .
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> -[edivn m d.+1]/(edivn_rec d m 0) <span style="font-weight: bold; text-decoration: underline;">in</span> ed *.
<span style="text-decoration: underline;">rewrite</span> -[m]/(0 * d.+1 + m).
</pre>
</div>

<pre class="example">
1 subgoal
  
  m, d : nat
  ed := edivn_rec d m 0 : nat * nat
  ============================
  (ed.2 &lt; d.+1) &amp;&amp; (m == ed.1 * d.+1 + ed.2)

1 subgoal
  
  m, d : nat
  ed := edivn_rec d m 0 : nat * nat
  ============================
  (ed.2 &lt; d.+1) &amp;&amp; (0 * d.+1 + m == ed.1 * d.+1 + ed.2)
</pre>

<p>
Then the next command does some <span class="underline">behold / local-definition generalization</span>
pre-processing by prefixing the <code>ed</code> beholding with the <code>@</code> modifier. Then the same
composite-command does <i>lessorequal-generalization</i> pre-processing, then some
<i>initial-accumulator-generalization</i> pre-processing, then query the <i>recursive
elimination scheme</i> for <code>nat</code> numbers. Finally the same composite-command does some
post-processing such as introducing some identifier-names and immediately-solving some
goals.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">elim</span>: m {-2}m 0 (leqnn m) @ed =&gt; [[]//=|n IHn [//=|m]] q le_mn.
</pre>
</div>

<pre class="example">
1 subgoal
  
  d, n : nat
  IHn : forall m n0 : nat,
        m &lt;= n -&gt;
        let ed := edivn_rec d m n0 in
        (ed.2 &lt; d.+1) &amp;&amp; (n0 * d.+1 + m == ed.1 * d.+1 + ed.2)
  m, q : nat
  le_mn : m &lt; n.+1
  ============================
  let ed := edivn_rec d m.+1 q in
  (ed.2 &lt; d.+1) &amp;&amp; (q * d.+1 + m.+1 == ed.1 * d.+1 + ed.2)
</pre>

<p>
The following lemmas shall be used in the next command :
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="font-weight: bold;">About</span> subn_if_gt.
<span style="font-weight: bold;">About</span> negbT.
</pre>
</div>

<pre class="example">
subn_if_gt :
forall (T : Type) (m n : nat) (F : nat -&gt; T) (E : T),
match m.+1 - n with
| 0 =&gt; E
| m'.+1 =&gt; F m'
end = (if n &lt;= m then F (m - n) else E)

Argument T is implicit
Argument scopes are [type_scope nat_scope nat_scope function_scope _]
subn_if_gt is opaque
Expands to: Constant mathcomp.ssreflect.ssrnat.subn_if_gt

negbT : forall b : bool, b = false -&gt; ~~ b

Argument b is implicit
Argument scopes are [bool_scope _]
negbT is opaque
Expands to: Constant mathcomp.ssreflect.ssrbool.negbT
</pre>

<p>
This next command unfolds the recursive function along the lemma <code>edivn_recE</code> and uses
the lemma <code>subn_if_gt</code> to push the subtraction into the branches of the if
statement. Then the following command pre-process the condition <code>(d &lt;= m)</code> of the
if-then-else statement by doing some <i>equational-generalize</i> of this condition, then
destructs this condition to expose the alternative cases, and finally post-process the
memorizing equation through branching and introduction filters which use the <i>apply-in
view</i> <code>/negbT</code>. Memo that the shorter equational-generalize command <code>case E : (d &lt;=
m)</code> may also be used instead of this long manual equational-generalize.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">rewrite</span> edivn_recE subn_if_gt;
<span style="text-decoration: underline;">case</span> : {-1}(d &lt;= m) (erefl (d &lt;= m)) =&gt; [le_dm | /negbT lt_md]; last first.
</pre>
</div>

<pre class="example">
2 subgoals
  
  d, n : nat
  IHn : forall m n0 : nat,
        m &lt;= n -&gt;
        let ed := edivn_rec d m n0 in
        (ed.2 &lt; d.+1) &amp;&amp; (n0 * d.+1 + m == ed.1 * d.+1 + ed.2)
  m, q : nat
  le_mn : m &lt; n.+1
  lt_md : ~~ (d &lt;= m)
  ============================
  let ed := (q, m.+1) in
  (ed.2 &lt; d.+1) &amp;&amp; (q * d.+1 + m.+1 == ed.1 * d.+1 + ed.2)

subgoal 2 is:
 let ed := edivn_rec d (m - d) q.+1 in
 (ed.2 &lt; d.+1) &amp;&amp; (q * d.+1 + m.+1 == ed.1 * d.+1 + ed.2)
</pre>

<p>
The else branch corresponds to the non recursive case of the division algorithm and
is immediately-solved by this command :
</p>

<div class="org-src-container">
<pre class="src src-coq">by <span style="text-decoration: underline;">rewrite</span> /= ltnS ltnNge lt_md eqxx.
</pre>
</div>

<pre class="example">
1 subgoal
  
  d, n : nat
  IHn : forall m n0 : nat,
        m &lt;= n -&gt;
        let ed := edivn_rec d m n0 in
        (ed.2 &lt; d.+1) &amp;&amp; (n0 * d.+1 + m == ed.1 * d.+1 + ed.2)
  m, q : nat
  le_mn : m &lt; n.+1
  le_dm : (d &lt;= m) = true
  ============================
  let ed := edivn_rec d (m - d) q.+1 in
  (ed.2 &lt; d.+1) &amp;&amp; (q * d.+1 + m.+1 == ed.1 * d.+1 + ed.2)
</pre>

<p>
The recursive query is done on <code>(m-d)</code>, hence the lack for <i>lessorequal-generalizing
induction</i> ( <i>strong induction</i> ). The premise for the induction hypothesis <code>(m - d &lt;=
n)</code> is deduced in some separate foward step via the <i>forward-generalize</i> <code>have</code>
command. This same command does some post-processing <i>specialization</i> view
introduction filter onto this intermediate lemma which is now some extra assumption of
the old goal.
</p>

<div class="org-src-container">
<pre class="src src-coq"><span style="text-decoration: underline;">have</span> /(IHn _ q.+1) : m - d &lt;= n by <span style="text-decoration: underline;">rewrite</span> (leq_trans (leq_subr d m)).
</pre>
</div>

<pre class="example">
1 subgoal
  
  d, n : nat
  IHn : forall m n0 : nat,
        m &lt;= n -&gt;
        let ed := edivn_rec d m n0 in
        (ed.2 &lt; d.+1) &amp;&amp; (n0 * d.+1 + m == ed.1 * d.+1 + ed.2)
  m, q : nat
  le_mn : m &lt; n.+1
  le_dm : (d &lt;= m) = true
  ============================
  (let ed := edivn_rec d (m - d) q.+1 in
   (ed.2 &lt; d.+1) &amp;&amp; (q.+1 * d.+1 + (m - d) == ed.1 * d.+1 + ed.2)) -&gt;
  let ed := edivn_rec d (m - d) q.+1 in
  (ed.2 &lt; d.+1) &amp;&amp; (q * d.+1 + m.+1 == ed.1 * d.+1 + ed.2)
</pre>

<p>
This final command deduces that some cancellation of numbers indeed does occur :
</p>

<div class="org-src-container">
<pre class="src src-coq">by <span style="text-decoration: underline;">rewrite</span> /= mulSnr -addnA -subSS subnKC.
<span style="font-weight: bold;">Qed</span>.
</pre>
</div>

<pre class="example">
No more subgoals.

(&lt;ssreflect_plugin::ssrtclseq@0&gt; case : d =&gt; [|d /=] in   ed * ; first  by
 rewrite eqxx).
rewrite -[edivn m d.+1]/(edivn_rec d m 0) in   ed *.
rewrite -[m]/(0 * d.+1 + m).
elim : m {-2}m 0 (leqnn m) @ed =&gt; [[] //=|n IHn [//=|m]] q le_mn.
(&lt;ssreflect_plugin::ssrtclseq@0&gt;
 rewrite edivn_recE subn_if_gt; case : {-1}(d &lt;= m) 
  (erefl (d &lt;= m)) =&gt; [le_dm|/negbT lt_md] ; last  first).
 by rewrite /= ltnS ltnNge lt_md eqxx.

 have /(IHn _ q.+1): m - d &lt;= nby rewrite (leq_trans (leq_subr d m)).
 by rewrite /= mulSnr -addnA -subSS subnKC.

Qed.
edivnP is defined
</pre>
</div>
</div>

<div id="outline-container-org116e8b9" class="outline-3">
<h3 id="org116e8b9"><span class="section-number-3">8.2</span> Review of OOO1337777</h3>
<div class="outline-text-3" id="text-8-2">
<p>
The <code>SOLUTION PROGRAMME</code> is some continuation of the <code>DOSEN PROGRAMME</code> <sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> and
the <code>COQ MATH-COMP PROGRAMME</code> <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> <sup>, </sup><sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.
</p>

<p>
The <code>SOLUTION PROGRAMME</code> has discovered <sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> <sup>, </sup><sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup> that the attempt to deduce
associative coherence by Maclance is in fact not the reality, because this famous
pentagone is in fact some recursive square.
</p>

<p>
Moreover the <code>SOLUTION PROGRAMME</code> has discovered <sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup> <sup>, </sup><sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup> that the categories
only-named by the homologist Maclane are in fact the natural polymorphism of the logic
of Gentzen, this enables some programming of congruent resolution by
cut-elimination <sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup> which will serve as specification (reflection) technique to
semi-decide the questions of coherence, in comparasion from the ssreflect-style.
</p>

<p>
Furthermore the <code>SOLUTION PROGRAMME</code> has discovered <sup><a id="fnr.9" class="footref" href="#fn.9">9</a></sup> <sup>, </sup><sup><a id="fnr.10" class="footref" href="#fn.10">10</a></sup> that the
Galois-action for the resolution-modulo, is in fact some instance of polymorph
functors.
</p>

<p>
And the <code>SOLUTION PROGRAMME</code> has discovered <sup><a id="fnr.11" class="footref" href="#fn.11">11</a></sup> <sup>, </sup><sup><a id="fnr.12" class="footref" href="#fn.12">12</a></sup> how to program polymorph
coparametrism functors ( "comonad" ).
</p>

<p>
Additionnally, the <code>SOLUTION PROGRAMME</code> has discovered
information-technology <sup><a id="fnr.13" class="footref" href="#fn.13">13</a></sup> <sup>, </sup><sup><a id="fnr.14" class="footref" href="#fn.14">14</a></sup> <sup>, </sup><sup><a id="fnr.15" class="footref" href="#fn.15">15</a></sup> based on the <span class="underline">EMACS org-mode</span> logiciel
which enables communication of <span class="underline">timed-synchronized</span> <span class="underline">geolocated</span>
<span class="underline">simultaneously-edited</span> <span class="underline">multi-authors</span> <span class="underline">searchable</span> text, and therefore communication
of textual COQ math programming, and which enables <span class="underline">webcitations / reviews</span>.
</p>

<p>
Whatever is discovered, its format, its communication is simultaneously some
predictable logical discovery and some random dia-para-logical discovery.
</p>
</div>
</div>
</div>


<div id="outline-container-orga8b5618" class="outline-2">
<h2 id="orga8b5618"><span class="section-number-2">9</span> ConfusPlay</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-org3bb20a0" class="outline-3">
<h3 id="org3bb20a0"><span class="section-number-3">9.1</span> ConfusPlay 1</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Correct this <code>all_words</code> program which input from some length <code>(n : nat)</code> and some
sequence of symbols alphabet <code>(alphabet : seq T)</code> and shall generate some list
containing any word-of-size-n, which signifies : some list of list-of-size-n.
</p>


<pre class="example">
Eval compute in all_words 2 [:: 1; 2; 3].
</pre>

<pre class="example">
= [:: [:: 1; 1]; [:: 1; 2]; [:: 1; 3];
[:: 2; 1]; [:: 2; 2]; [:: 2; 3];
[:: 3; 1]; [:: 3; 2]; [:: 3; 3]]
</pre>

<pre class="example">
Definition all_words (n : nat) (T : Type) (alphabet : seq T) :=
  let prepend x wl := [seq x :: w | w &lt;- wl] in
  let extend wl := flatten [seq prepend x wl | x &lt;- alphabet] in
    iter n extend [::].
</pre>
</div>
</div>

<div id="outline-container-org86b2750" class="outline-3">
<h3 id="org86b2750"><span class="section-number-3">9.2</span> ConfusPlay 2, refer <a href="#org3bb20a0">ConfusPlay 1</a></h3>
<div class="outline-text-3" id="text-9-2">
<p>
Complete this <code>size_all_words</code> lemma by filling-in the two blank spaces marked by
<code>(** ???1 **)</code> and <code>(** ???2 **)</code> . Then separate this lemma in two distincts lemmas
<code>size_extend</code> and <code>size_all_words</code> such that this
nested-(double)-induction-in-single-lemma is erased.
</p>

<pre class="example">
Lemma size_all_words n T (alphabet : seq T) :
  size (all_words n alphabet) = size alphabet ^ n.

elim: n =&gt; [|n IHn]; first by rewrite expn0.
rewrite expnS -{}(** ???1 **) [in LHS]/all_words iterS -/(all_words _ _).

elim: alphabet (all_words _ _) =&gt; //= w ws IHws aw.
by rewrite size_cat (** ???2 **) size_map mulSn.
Qed.
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<code>DOSEN</code> <a href="http://www.mi.sanu.ac.rs/~kosta">http://www.mi.sanu.ac.rs/~kosta</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<code>COQ</code> <a href="https://coq.inria.fr/">https://coq.inria.fr/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://1337777.github.io/init.html">https://1337777.github.io/init.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/dosen/blob/master/coherence2.v">https://github.com/1337777/dosen/blob/master/coherence2.v</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/dosen/blob/master/coherence.v">https://github.com/1337777/dosen/blob/master/coherence.v</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/borceux/blob/master/borceuxSolution2.v">https://github.com/1337777/borceux/blob/master/borceuxSolution2.v</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/borceux/blob/master/chic05.pdf">https://github.com/1337777/borceux/blob/master/chic05.pdf</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/dosen/blob/master/dosenSolution3.v">https://github.com/1337777/dosen/blob/master/dosenSolution3.v</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9">9</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/aigner/blob/master/aignerSolution.v">https://github.com/1337777/aigner/blob/master/aignerSolution.v</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10">10</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/aigner/blob/master/ocic04-where-is-combinatorics.pdf">https://github.com/1337777/aigner/blob/master/ocic04-where-is-combinatorics.pdf</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11">11</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/laozi/blob/master/ocic03-what-is-normal.djvu">https://github.com/1337777/laozi/blob/master/ocic03-what-is-normal.djvu</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12">12</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/laozi/blob/master/laoziSolution2.v">https://github.com/1337777/laozi/blob/master/laoziSolution2.v</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13">13</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/OOO1337777/blob/master/makegit.sh.org">https://github.com/1337777/OOO1337777/blob/master/makegit.sh.org</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14">14</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="http://1337777.link/ooo/guJAH-jSeQcTEST/2016/1/5/11/9/11/1">http://1337777.link/ooo/guJAH-jSeQcTEST/2016/1/5/11/9/11/1</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15">15</a></sup> <div class="footpara"><p class="footpara">
<code>1337777.OOO</code> <a href="https://github.com/1337777/upo/blob/master/editableTree.urp">https://github.com/1337777/upo/blob/master/editableTree.urp</a>
</p></div></div>


</div>
</div></div>
</body>
</html>
